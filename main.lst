#[1]   main.asm
   34           2000      	.zp
   35                     	
   36  --:2000            	scroll_x: .ds 2
   37  --:2002            	scroll_y: .ds 2
   38  --:2004            	status: .ds 1
   39  --:2005            	frame: .ds 2
   40  --:2007            	joypad: .ds 1
   41  --:2008            	joyedge: .ds 1 ;1 when pad transitioned from 0 to 1
   42                     
   43           E000      	.data
   44                     
   45           602F      	.code
   46           0000      	.bank   0
   47           4070      	.org    $4070
   48                     
   49                     ;
   50                     ;
   51                     ;
   52  00:4070            boot:
   53  00:4070  20 99 E0  	jsr     ex_dspoff
   54  00:4073  20 81 E0  	jsr     ex_rcroff
   55  00:4076  20 87 E0  	jsr     ex_irqoff
   56  00:4079  20 30 E0  	jsr     ad_reset
   57                     
   58  00:407C  20 A6 42  	jsr     init_vce
   59                     
   60                     	stw     #boot_video_mode,_ax
       00:407F  A9 D6     	lda	LOW_BYTE #boot_video_mode
       00:4081  8D F8 20  	sta	LOW_BYTE _ax
       00:4084  A9 42     	lda	HIGH_BYTE #boot_video_mode
       00:4086  8D F9 20  	sta	HIGH_BYTE _ax
   61  00:4089  20 8B 42  	jsr     init_vdc
   62                     	
   63                     	;set up vsync handler
   64                     	stw #my_vsync,sync_jmp
       00:408C  A9 73     	lda	LOW_BYTE #my_vsync
       00:408E  8D 08 22  	sta	LOW_BYTE sync_jmp
       00:4091  A9 42     	lda	HIGH_BYTE #my_vsync
       00:4093  8D 09 22  	sta	HIGH_BYTE sync_jmp
   65  00:4096  A9 30     	lda #%00110000
   66  00:4098  8D F5 20  	sta irq_m
   67  00:409B  20 96 E0  	jsr ex_dspon
   68  00:409E  20 7E E0  	jsr ex_rcron
   69  00:40A1  20 84 E0  	jsr ex_irqon
   70  00:40A4  20 7B E0  	jsr ex_vsync
   71  00:40A7  20 7B E0  	jsr ex_vsync
   72                     	
   73                     	;load level gfx & map
   74                     	cd_load _ADDR_level1,#$82,#8
       00:40AA  64 FC     	stz <_cl ;sector number (bits 24-16)
       00:40AC  A9 00     	lda #HIGH(_ADDR_level1) ;sector number (bits 15-8)
       00:40AE  85 FD     	sta <_ch
       00:40B0  A9 0A     	lda #LOW(_ADDR_level1) ;sector number (bits 7-0)
       00:40B2  85 FE     	sta <_dl
       00:40B4  A9 02     	lda #2 ;write to a bank
       00:40B6  85 FF     	sta <_dh
       00:40B8  A9 82     	lda #$82 ;write starting at bank n
       00:40BA  85 FA     	sta <_bl
       00:40BC  A9 08     	lda #8 ;write n sectors
       00:40BE  85 F8     	sta <_al
       00:40C0  20 00 60  	jsr cd_saferead
   75                     	
   76                     	;play cdda
   77                     	; lda #2 ;track 2
   78                     	; jsr cd_track
   79                     	
   80                     	;copy bg palette
   81                     	stw     #pal_load,<_ax
       00:40C3  A9 00     	lda	LOW_BYTE #pal_load
       00:40C5  85 F8     	sta	LOW_BYTE <_ax
       00:40C7  A9 A0     	lda	HIGH_BYTE #pal_load
       00:40C9  85 F9     	sta	HIGH_BYTE <_ax
   82                     	stw     #$0000,VCE_ADDR_LO
       00:40CB  A9 00     	lda	LOW_BYTE #$0000
       00:40CD  8D 02 04  	sta	LOW_BYTE VCE_ADDR_LO
       00:40D0  A9 00     	lda	HIGH_BYTE #$0000
       00:40D2  8D 03 04  	sta	HIGH_BYTE VCE_ADDR_LO
   83  00:40D5  20 C4 42  	jsr     copy_palette
   84                     
   85                     	;copy bg data
   86                     	vreg #VDC_MAWR
       00:40D8  A9 00     	lda	#VDC_MAWR
       00:40DA  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:40DC  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   87                     	stw #$2000,video_data
       00:40DE  A9 00     	lda	LOW_BYTE #$2000
       00:40E0  8D 02 00  	sta	LOW_BYTE video_data
       00:40E3  A9 20     	lda	HIGH_BYTE #$2000
       00:40E5  8D 03 00  	sta	HIGH_BYTE video_data
   88                     	vreg #VDC_VWR
       00:40E8  A9 02     	lda	#VDC_VWR
       00:40EA  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:40EC  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   89  00:40EE  E3 00 80  	tia tile_load,video_data,$2000
       00:40F1  02 00 00  
       00:40F4  20        
   90                     
   91                     	;tilemap uses 16x16 tiles, so make it 8x8 like the vdc expects
   92                     	stwz <_di ;pointer to video start address
       00:40F5  64 F0     	stz	LOW_BYTE <_di
       00:40F7  64 F1     	stz	HIGH_BYTE <_di
   93                     	stw #map_load,<_si
       00:40F9  A9 20     	lda	LOW_BYTE #map_load
       00:40FB  85 EE     	sta	LOW_BYTE <_si
       00:40FD  A9 A0     	lda	HIGH_BYTE #map_load
       00:40FF  85 EF     	sta	HIGH_BYTE <_si
   94  00:4101  A9 20     	lda #32 ;32 columns
   95  00:4103  85 FE     	sta <_dl
   96  00:4105            .col_loop:
   97                     ;tile num = (num >> 3) * $20 + (num & 7) * 2
   98                     ;         = ((num & $fff8) << 2) + ((num & 7) << 1)
   99  00:4105  A2 20     	ldx #32 ;32 rows
  100  00:4107  C2        	cly
  101  00:4108            .row_loop:
  102  00:4108  B1 EE     	lda [<_si],y
  103  00:410A  85 F8     	sta <_al
  104                     	;((num & 7) << 1)
  105  00:410C  29 07     	and #$7
  106  00:410E  0A        	asl a
  107  00:410F  85 FA     	sta <_bl
  108                     
  109  00:4111  C8        	iny
  110  00:4112  B1 EE     	lda [<_si],y
  111  00:4114  85 F9     	sta <_ah
  112  00:4116  64 FB     	stz <_bh
  113  00:4118  C8        	iny
  114                     	;((num & #$fff8) << 2)
  115                     	andw <_ax,#$fff8
       00:4119  A5 F8     	lda	LOW_BYTE <_ax
       00:411B  29 F8     	and LOW_BYTE #$fff8
       00:411D  85 F8     	sta LOW_BYTE <_ax
       00:411F  A5 F9     	lda HIGH_BYTE <_ax
       00:4121  29 FF     	and HIGH_BYTE #$fff8
       00:4123  85 F9     	sta HIGH_BYTE <_ax
  116                     	aslw <_ax
       00:4125  06 F8     	asl	<_ax		; word-sized value (at stated
       00:4127  26 F9     	rol	<_ax+1		; memory location)
  117                     	aslw <_ax
       00:4129  06 F8     	asl	<_ax		; word-sized value (at stated
       00:412B  26 F9     	rol	<_ax+1		; memory location)
  118                     	addw <_ax,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:412D  18        	clc
       00:412E  A5 FA     	lda	LOW_BYTE <_bx
       00:4130  65 F8     	adc	LOW_BYTE <_ax
       00:4132  85 FA     	sta	LOW_BYTE <_bx
       00:4134  A5 FB     	lda	HIGH_BYTE <_bx
       00:4136  65 F9     	adc	HIGH_BYTE <_ax
       00:4138  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  119                     	addw #$200,<_bx ;tile numbers start at $200
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:413A  18        	clc
       00:413B  A5 FA     	lda	LOW_BYTE <_bx
       00:413D  69 00     	adc	LOW_BYTE #$200
       00:413F  85 FA     	sta	LOW_BYTE <_bx
       00:4141  A5 FB     	lda	HIGH_BYTE <_bx
       00:4143  69 02     	adc	HIGH_BYTE #$200
       00:4145  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  120                     	;correct tile number for upper left corner of 16x16 tile now in _bx
  121                     	vreg #VDC_MAWR
       00:4147  A9 00     	lda	#VDC_MAWR
       00:4149  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:414B  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  122                     	stw <_di,video_data
       00:414D  A5 F0     	lda	LOW_BYTE <_di
       00:414F  8D 02 00  	sta	LOW_BYTE video_data
       00:4152  A5 F1     	lda	HIGH_BYTE <_di
       00:4154  8D 03 00  	sta	HIGH_BYTE video_data
  123                     	vreg #VDC_VWR
       00:4157  A9 02     	lda	#VDC_VWR
       00:4159  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:415B  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  124                     	stw <_bx,video_data
       00:415D  A5 FA     	lda	LOW_BYTE <_bx
       00:415F  8D 02 00  	sta	LOW_BYTE video_data
       00:4162  A5 FB     	lda	HIGH_BYTE <_bx
       00:4164  8D 03 00  	sta	HIGH_BYTE video_data
  125                     	;upper right corner
  126                     	incw <_bx
       00:4167  E6 FA     	inc	<_bx		; value at stated memory
       00:4169  D0 02     	bne	.x_00020		; location
       00:416B  E6 FB     	inc	<_bx+1
       00:416D            .x_00020:
  127                     	stw <_bx,video_data
       00:416D  A5 FA     	lda	LOW_BYTE <_bx
       00:416F  8D 02 00  	sta	LOW_BYTE video_data
       00:4172  A5 FB     	lda	HIGH_BYTE <_bx
       00:4174  8D 03 00  	sta	HIGH_BYTE video_data
  128                     	;lower left corner
  129                     	addw #$f,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:4177  18        	clc
       00:4178  A5 FA     	lda	LOW_BYTE <_bx
       00:417A  69 0F     	adc	LOW_BYTE #$f
       00:417C  85 FA     	sta	LOW_BYTE <_bx
       00:417E  A5 FB     	lda	HIGH_BYTE <_bx
       00:4180  69 00     	adc	HIGH_BYTE #$f
       00:4182  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  130                     	;screen is on next row (64x64 tilemap)
  131                     	addw #$40,<_di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:4184  18        	clc
       00:4185  A5 F0     	lda	LOW_BYTE <_di
       00:4187  69 40     	adc	LOW_BYTE #$40
       00:4189  85 F0     	sta	LOW_BYTE <_di
       00:418B  A5 F1     	lda	HIGH_BYTE <_di
       00:418D  69 00     	adc	HIGH_BYTE #$40
       00:418F  85 F1     	sta	HIGH_BYTE <_di
                          .endif
  132                     	vreg #VDC_MAWR
       00:4191  A9 00     	lda	#VDC_MAWR
       00:4193  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:4195  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  133                     	stw <_di,video_data
       00:4197  A5 F0     	lda	LOW_BYTE <_di
       00:4199  8D 02 00  	sta	LOW_BYTE video_data
       00:419C  A5 F1     	lda	HIGH_BYTE <_di
       00:419E  8D 03 00  	sta	HIGH_BYTE video_data
  134                     	vreg #VDC_VWR
       00:41A1  A9 02     	lda	#VDC_VWR
       00:41A3  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41A5  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  135                     	stw <_bx,video_data
       00:41A7  A5 FA     	lda	LOW_BYTE <_bx
       00:41A9  8D 02 00  	sta	LOW_BYTE video_data
       00:41AC  A5 FB     	lda	HIGH_BYTE <_bx
       00:41AE  8D 03 00  	sta	HIGH_BYTE video_data
  136                     	;lower right corner
  137                     	incw <_bx
       00:41B1  E6 FA     	inc	<_bx		; value at stated memory
       00:41B3  D0 02     	bne	.x_00028		; location
       00:41B5  E6 FB     	inc	<_bx+1
       00:41B7            .x_00028:
  138                     	stw <_bx,video_data
       00:41B7  A5 FA     	lda	LOW_BYTE <_bx
       00:41B9  8D 02 00  	sta	LOW_BYTE video_data
       00:41BC  A5 FB     	lda	HIGH_BYTE <_bx
       00:41BE  8D 03 00  	sta	HIGH_BYTE video_data
  139                     	;restore vram address to where it should be for the next tile
  140                     	subw #$3e,<_di ;each row is $40, so subtracting $3e is like
       00:41C1  38        	sec
       00:41C2  A5 F0     	lda	LOW_BYTE <_di
       00:41C4  E9 3E     	sbc	LOW_BYTE #$3e
       00:41C6  85 F0     	sta	LOW_BYTE <_di
       00:41C8  A5 F1     	lda	HIGH_BYTE <_di
       00:41CA  E9 00     	sbc	HIGH_BYTE #$3e
       00:41CC  85 F1     	sta	HIGH_BYTE <_di
  141                     	vreg #VDC_MAWR ;subtracting $40 and adding $2
       00:41CE  A9 00     	lda	#VDC_MAWR
       00:41D0  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41D2  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  142                     	stw <_di,video_data
       00:41D4  A5 F0     	lda	LOW_BYTE <_di
       00:41D6  8D 02 00  	sta	LOW_BYTE video_data
       00:41D9  A5 F1     	lda	HIGH_BYTE <_di
       00:41DB  8D 03 00  	sta	HIGH_BYTE video_data
  143                     	vreg #VDC_VWR
       00:41DE  A9 02     	lda	#VDC_VWR
       00:41E0  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41E2  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  144  00:41E4  CA        	dex
  145  00:41E5  F0 03     	beq .done_row
  146  00:41E7  4C 08 41  	jmp .row_loop
  147  00:41EA            .done_row:
  148  00:41EA  A5 FE     	lda <_dl
  149  00:41EC  3A        	dec a
  150  00:41ED  F0 1F     	beq .done
  151  00:41EF  85 FE     	sta <_dl
  152                     	addw #$80,<_si ;map is 64x32, each tile index is 2 bytes
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:41F1  18        	clc
       00:41F2  A5 EE     	lda	LOW_BYTE <_si
       00:41F4  69 80     	adc	LOW_BYTE #$80
       00:41F6  85 EE     	sta	LOW_BYTE <_si
       00:41F8  A5 EF     	lda	HIGH_BYTE <_si
       00:41FA  69 00     	adc	HIGH_BYTE #$80
       00:41FC  85 EF     	sta	HIGH_BYTE <_si
                          .endif
  153                     	addw #$40,<_di ;skip every other row of the tilemap
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:41FE  18        	clc
       00:41FF  A5 F0     	lda	LOW_BYTE <_di
       00:4201  69 40     	adc	LOW_BYTE #$40
       00:4203  85 F0     	sta	LOW_BYTE <_di
       00:4205  A5 F1     	lda	HIGH_BYTE <_di
       00:4207  69 00     	adc	HIGH_BYTE #$40
       00:4209  85 F1     	sta	HIGH_BYTE <_di
                          .endif
  154  00:420B  4C 05 41  	jmp .col_loop
  155  00:420E            .done:
  156                     	
  157                     	;init scroll
  158                     	stwz <scroll_x
       00:420E  64 00     	stz	LOW_BYTE <scroll_x
       00:4210  64 01     	stz	HIGH_BYTE <scroll_x
  159                     	stwz <scroll_y
       00:4212  64 02     	stz	LOW_BYTE <scroll_y
       00:4214  64 03     	stz	HIGH_BYTE <scroll_y
  160                     	;main loop
  161  00:4216            main:
  162  00:4216  4F 07 06  	bbr4 <joypad,.no_up
  163                     	incw <scroll_y
       00:4219  E6 02     	inc	<scroll_y		; value at stated memory
       00:421B  D0 02     	bne	.x_00038		; location
       00:421D  E6 03     	inc	<scroll_y+1
       00:421F            .x_00038:
  164  00:421F            .no_up:
  165  00:421F  5F 07 0D  	bbr5 <joypad,.no_right
  166                     	decw <scroll_x
       00:4222  38        	sec			; value at stated memory
       00:4223  A5 00     	lda	<scroll_x		; location
       00:4225  E9 01     	sbc	#1
       00:4227  85 00     	sta	<scroll_x
       00:4229  A5 01     	lda	<scroll_x+1
       00:422B  E9 00     	sbc	#0
       00:422D  85 01     	sta	<scroll_x+1
  167  00:422F            .no_right:
  168  00:422F  6F 07 0D  	bbr6 <joypad,.no_down
  169                     	decw <scroll_y
       00:4232  38        	sec			; value at stated memory
       00:4233  A5 02     	lda	<scroll_y		; location
       00:4235  E9 01     	sbc	#1
       00:4237  85 02     	sta	<scroll_y
       00:4239  A5 03     	lda	<scroll_y+1
       00:423B  E9 00     	sbc	#0
       00:423D  85 03     	sta	<scroll_y+1
  170  00:423F            .no_down:
  171  00:423F  7F 07 06  	bbr7 <joypad,.no_left
  172                     	incw <scroll_x
       00:4242  E6 00     	inc	<scroll_x		; value at stated memory
       00:4244  D0 02     	bne	.x_00041		; location
       00:4246  E6 01     	inc	<scroll_x+1
       00:4248            .x_00041:
  173  00:4248            .no_left:
  174                     
  175                     
  176                     	vreg #VDC_BXR
       00:4248  A9 07     	lda	#VDC_BXR
       00:424A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:424C  03 07     	st0	#VDC_BXR
                          .else
                          .endif
  177                     	stw <scroll_x,video_data
       00:424E  A5 00     	lda	LOW_BYTE <scroll_x
       00:4250  8D 02 00  	sta	LOW_BYTE video_data
       00:4253  A5 01     	lda	HIGH_BYTE <scroll_x
       00:4255  8D 03 00  	sta	HIGH_BYTE video_data
  178                     	vreg #VDC_BYR
       00:4258  A9 08     	lda	#VDC_BYR
       00:425A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:425C  03 08     	st0	#VDC_BYR
                          .else
                          .endif
  179                     	stw <scroll_y,video_data
       00:425E  A5 02     	lda	LOW_BYTE <scroll_y
       00:4260  8D 02 00  	sta	LOW_BYTE video_data
       00:4263  A5 03     	lda	HIGH_BYTE <scroll_y
       00:4265  8D 03 00  	sta	HIGH_BYTE video_data
  180                     	
  181                     	; jsr ex_vsync
  182  00:4268  A9 01     	lda #1
  183  00:426A  85 04     	sta <status
  184  00:426C            end_loop:
  185                     ;loop until vsync function sets status to 0
  186  00:426C  A5 04     	lda <status
  187  00:426E  D0 FC     	bne end_loop
  188  00:4270  4C 16 42  	jmp main
  189                     	
  190  00:4273            my_vsync:	
  191                     	incw <frame
       00:4273  E6 05     	inc	<frame		; value at stated memory
       00:4275  D0 02     	bne	.x_00046		; location
       00:4277  E6 06     	inc	<frame+1
       00:4279            .x_00046:
  192  00:4279  64 04     	stz <status
  193                     	
  194  00:427B  A9 01     	lda #1 ;read joypad 1
  195  00:427D  20 63 E0  	jsr ex_joysns
  196  00:4280  AD 28 22  	lda joy
  197  00:4283  85 07     	sta <joypad
  198  00:4285  AD 2D 22  	lda joytrg
  199  00:4288  85 08     	sta <joyedge
  200  00:428A  60        	rts
  201                     	
  202                     ; ***************************************************************************
  203                     ; ***************************************************************************
  204                     ;
  205                     ;
  206                     
  207                     
  208  00:428B            init_vdc:
  209  00:428B  08        	php
  210  00:428C  78        	sei
  211  00:428D  C2        	cly
  212  00:428E            .loop:
  213  00:428E  B1 F8     	lda     [_ax],y
  214  00:4290  F0 12     	beq     .done
  215  00:4292  8D 00 00  	sta     VDC_CTRL
  216  00:4295  C8        	iny
  217  00:4296  B1 F8     	lda     [_ax],y
  218  00:4298  8D 02 00  	sta     VDC_DATA_LO
  219  00:429B  C8        	iny
  220  00:429C  B1 F8     	lda     [_ax],y
  221  00:429E  8D 03 00  	sta     VDC_DATA_HI
  222  00:42A1  C8        	iny
  223  00:42A2  80 EA     	bra     .loop
  224  00:42A4            .done:
  225  00:42A4  28        	plp
  226  00:42A5  60        	rts
  227                     
  228                     
  229                     ; ***************************************************************************
  230                     ; ***************************************************************************
  231                     ;
  232                     ;
  233                     
  234  00:42A6            init_vce:
  235  00:42A6  08        	php
  236  00:42A7  78        	sei
  237  00:42A8  9C 02 04  	stz     VCE_ADDR_LO
  238  00:42AB  9C 03 04  	stz     VCE_ADDR_HI
  239  00:42AE  A0 02     	ldy     #$02
  240  00:42B0  82        	clx
  241  00:42B1            .loop:
  242  00:42B1  9C 04 04  	stz     VCE_DATA_LO
  243  00:42B4  9C 05 04  	stz     VCE_DATA_HI
  244  00:42B7  CA        	dex
  245  00:42B8  D0 F7     	bne     .loop
  246  00:42BA  88        	dey
  247  00:42BB  D0 F4     	bne     .loop
  248  00:42BD  A9 00     	lda     #VCE_CR_5MHz
  249  00:42BF  8D 00 04  	sta     VCE_CTRL
  250  00:42C2  28        	plp
  251  00:42C3  60        	rts
  252                     
  253                     
  254                     ; ***************************************************************************
  255                     ; ***************************************************************************
  256                     ;
  257                     ;
  258                     
  259  00:42C4            copy_palette:   
  260  00:42C4  C2        	cly
  261  00:42C5            .loop:
  262  00:42C5  B1 F8     	lda     [_ax],y
  263  00:42C7  C8        	iny
  264  00:42C8  8D 04 04  	sta     VCE_DATA_LO
  265  00:42CB  B1 F8     	lda     [_ax],y
  266  00:42CD  C8        	iny
  267  00:42CE  8D 05 04  	sta     VCE_DATA_HI
  268  00:42D1  C0 20     	cpy     #32
  269  00:42D3  D0 F0     	bne     .loop
  270  00:42D5  60        	rts
  271                     
  272                     
  273                     ; ***************************************************************************
  274                     ; ***************************************************************************
  275                     
  276                     ; VDC constants for 240 & 256 wide display.
  277                     
  278           0000      VCE_CR_5MHz  = $00
  279                     
  280           0302      VDC_HSR_240  = $0302
  281           041D      VDC_HDR_240  = $041D
  282                     
  283           0202      VDC_HSR_256  = $0202
  284           041F      VDC_HDR_256  = $041F
  285                     
  286                     ; VDC constants for 320 & 336 wide display.
  287                     
  288           0001      VCE_CR_7MHz  = $01
  289                     
  290           0502      VDC_HSR_320  = $0502
  291           0427      VDC_HDR_320  = $0427
  292                     
  293           0402      VDC_HSR_336  = $0402
  294           0429      VDC_HDR_336  = $0429
  295                     
  296                     ; VDC constants for 480 & 512 wide display.
  297                     
  298           0002      VCE_CR_10MHz = $02
  299                     
  300           0C02      VDC_HSR_480  = $0C02
  301           043C      VDC_HDR_480  = $043C
  302                     
  303           0B02      VDC_HSR_512  = $0B02
  304           043F      VDC_HDR_512  = $043F
  305                     
  306                     ; VDC constants for 200, 224 & 240 high display.
  307                     
  308           2302      VDC_VPR_200  = $2302
  309           00C7      VDC_VDW_200  = $00C7
  310           0018      VDC_VCR_200  = $0018
  311                     
  312           1702      VDC_VPR_224  = $1702
  313           00DF      VDC_VDW_224  = $00DF
  314           000C      VDC_VCR_224  = $000C
  315                     
  316           0F02      VDC_VPR_240  = $0F02
  317           00EF      VDC_VDW_240  = $00EF
  318           0004      VDC_VCR_240  = $0004 ; $00F6
  319                     
  320                     ; VDC constants for different BAT screen sizes.
  321                     
  322           0000      VDC_MWR_32x32  = $0000
  323           0040      VDC_MWR_32x64  = $0040
  324                     
  325           0010      VDC_MWR_64x32  = $0010
  326           0050      VDC_MWR_64x64  = $0050
  327                     
  328           0020      VDC_MWR_128x32 = $0020
  329           0060      VDC_MWR_128x64 = $0060
  330                     
  331                     ; Table of VDC values to set on boot.
  332                     
  333  00:42D6            boot_video_mode:
  334  00:42D6  05        	.db     VDC_CR                  ; Control Register
  335  00:42D7  00 00     	.dw     $0000
  336  00:42D9  06        	.db     VDC_RCR                 ; Raster Counter Register
  337  00:42DA  00 00     	.dw     $0000
  338  00:42DC  07        	.db     VDC_BXR                 ; Background X-Scroll Register
  339  00:42DD  00 00     	.dw     $0000
  340  00:42DF  08        	.db     VDC_BYR                 ; Background Y-Scroll Register
  341  00:42E0  00 00     	.dw     $0000
  342  00:42E2  09        	.db     VDC_MWR                 ; Memory-access Width Register
  343  00:42E3  50 00     	.dw     VDC_MWR_64x64
  344  00:42E5  0A        	.db     VDC_HSR                 ; Horizontal Sync Register
  345  00:42E6  02 02     	.dw     VDC_HSR_256
  346  00:42E8  0B        	.db     VDC_HDR                 ; Horizontal Display Register
  347  00:42E9  1F 04     	.dw     VDC_HDR_256
  348  00:42EB  0C        	.db     VDC_VPR                 ; Vertical Sync Register
  349  00:42EC  02 17     	.dw     VDC_VPR_224
  350  00:42EE  0D        	.db     VDC_VDW                 ; Vertical Display Register
  351  00:42EF  DF 00     	.dw     VDC_VDW_224
  352  00:42F1  0E        	.db     VDC_VCR                 ; Vertical Display END position Register
  353  00:42F2  0C 00     	.dw     VDC_VCR_224
  354  00:42F4  0F        	.db     VDC_DCR                 ; DMA Control Register
  355  00:42F5  10 00     	.dw     $0010
  356  00:42F7  13        	.db     VDC_SATB                ; SATB  address of the SATB
  357  00:42F8  7F 00     	.dw     $007F
  358  00:42FA  00        	.db     0
  359                     
  360                     	
