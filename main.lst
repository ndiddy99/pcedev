#[1]   main.asm
   18           0001      	.bank 1
   19           602F      	.code
   20                     
   21           000E      NUM_ROWS equ 14 ;14 rows (256x224 resolution, 224/16)
   22           0010      NUM_COLS equ 16 ;16 columns (256x224 resolution, 256/16)
   23           0020      MAP_WIDTH equ 32
   24           0020      MAP_HEIGHT equ 32
   25                     
   26                     ;load a level into vram
   27                     ;_si: map pointer
   28  01:602F            scroll_fill:
   29                     	stwz <_di ;pointer to vram BAT address
       01:602F  64 F0     	stz	LOW_BYTE <_di
       01:6031  64 F1     	stz	HIGH_BYTE <_di
   30  01:6033  A9 20     	lda #MAP_HEIGHT
   31  01:6035  85 FE     	sta <_dl
   32  01:6037            .col_loop:
   33                     ;tile num = (num >> 3) * $20 + (num & 7) * 2
   34                     ;         = ((num & $fff8) << 2) + ((num & 7) << 1)
   35  01:6037  A2 20     	ldx #MAP_WIDTH
   36  01:6039  C2        	cly
   37  01:603A            .row_loop:
   38  01:603A  B1 EE     	lda [<_si],y
   39  01:603C  85 F8     	sta <_al ;_ax is the first "num"
   40                     	;((num & 7) << 1)
   41  01:603E  29 07     	and #$7
   42  01:6040  0A        	asl a
   43  01:6041  85 FA     	sta <_bl ;_bx is the second "num"
   44                     
   45  01:6043  C8        	iny
   46  01:6044  B1 EE     	lda [<_si],y
   47  01:6046  85 F9     	sta <_ah
   48  01:6048  64 FB     	stz <_bh
   49  01:604A  C8        	iny
   50                     	;((num & #$fff8) << 2)
   51                     	andw <_ax,#$fff8
       01:604B  A5 F8     	lda	LOW_BYTE <_ax
       01:604D  29 F8     	and LOW_BYTE #$fff8
       01:604F  85 F8     	sta LOW_BYTE <_ax
       01:6051  A5 F9     	lda HIGH_BYTE <_ax
       01:6053  29 FF     	and HIGH_BYTE #$fff8
       01:6055  85 F9     	sta HIGH_BYTE <_ax
   52                     	aslw <_ax
       01:6057  06 F8     	asl	<_ax		; word-sized value (at stated
       01:6059  26 F9     	rol	<_ax+1		; memory location)
   53                     	aslw <_ax
       01:605B  06 F8     	asl	<_ax		; word-sized value (at stated
       01:605D  26 F9     	rol	<_ax+1		; memory location)
   54                     	addw <_ax,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:605F  18        	clc
       01:6060  A5 FA     	lda	LOW_BYTE <_bx
       01:6062  65 F8     	adc	LOW_BYTE <_ax
       01:6064  85 FA     	sta	LOW_BYTE <_bx
       01:6066  A5 FB     	lda	HIGH_BYTE <_bx
       01:6068  65 F9     	adc	HIGH_BYTE <_ax
       01:606A  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   55                     	addw #$200,<_bx ;tile numbers start at $200
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:606C  18        	clc
       01:606D  A5 FA     	lda	LOW_BYTE <_bx
       01:606F  69 00     	adc	LOW_BYTE #$200
       01:6071  85 FA     	sta	LOW_BYTE <_bx
       01:6073  A5 FB     	lda	HIGH_BYTE <_bx
       01:6075  69 02     	adc	HIGH_BYTE #$200
       01:6077  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   56                     	;correct tile number for upper left corner of 16x16 tile now in _bx
   57                     	vreg #VDC_MAWR
       01:6079  A9 00     	lda	#VDC_MAWR
       01:607B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:607D  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   58                     	stw <_di,video_data
       01:607F  A5 F0     	lda	LOW_BYTE <_di
       01:6081  8D 02 00  	sta	LOW_BYTE video_data
       01:6084  A5 F1     	lda	HIGH_BYTE <_di
       01:6086  8D 03 00  	sta	HIGH_BYTE video_data
   59                     	vreg #VDC_VWR
       01:6089  A9 02     	lda	#VDC_VWR
       01:608B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:608D  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   60                     	stw <_bx,video_data
       01:608F  A5 FA     	lda	LOW_BYTE <_bx
       01:6091  8D 02 00  	sta	LOW_BYTE video_data
       01:6094  A5 FB     	lda	HIGH_BYTE <_bx
       01:6096  8D 03 00  	sta	HIGH_BYTE video_data
   61                     	;upper right corner
   62                     	incw <_bx
       01:6099  E6 FA     	inc	<_bx		; value at stated memory
       01:609B  D0 02     	bne	.x_00011		; location
       01:609D  E6 FB     	inc	<_bx+1
       01:609F            .x_00011:
   63                     	stw <_bx,video_data
       01:609F  A5 FA     	lda	LOW_BYTE <_bx
       01:60A1  8D 02 00  	sta	LOW_BYTE video_data
       01:60A4  A5 FB     	lda	HIGH_BYTE <_bx
       01:60A6  8D 03 00  	sta	HIGH_BYTE video_data
   64                     	;lower left corner
   65                     	addw #$f,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:60A9  18        	clc
       01:60AA  A5 FA     	lda	LOW_BYTE <_bx
       01:60AC  69 0F     	adc	LOW_BYTE #$f
       01:60AE  85 FA     	sta	LOW_BYTE <_bx
       01:60B0  A5 FB     	lda	HIGH_BYTE <_bx
       01:60B2  69 00     	adc	HIGH_BYTE #$f
       01:60B4  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   66                     	;screen is on next row (64x64 tilemap)
   67                     	addw #$40,<_di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:60B6  18        	clc
       01:60B7  A5 F0     	lda	LOW_BYTE <_di
       01:60B9  69 40     	adc	LOW_BYTE #$40
       01:60BB  85 F0     	sta	LOW_BYTE <_di
       01:60BD  A5 F1     	lda	HIGH_BYTE <_di
       01:60BF  69 00     	adc	HIGH_BYTE #$40
       01:60C1  85 F1     	sta	HIGH_BYTE <_di
                          .endif
   68                     	vreg #VDC_MAWR
       01:60C3  A9 00     	lda	#VDC_MAWR
       01:60C5  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:60C7  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   69                     	stw <_di,video_data
       01:60C9  A5 F0     	lda	LOW_BYTE <_di
       01:60CB  8D 02 00  	sta	LOW_BYTE video_data
       01:60CE  A5 F1     	lda	HIGH_BYTE <_di
       01:60D0  8D 03 00  	sta	HIGH_BYTE video_data
   70                     	vreg #VDC_VWR
       01:60D3  A9 02     	lda	#VDC_VWR
       01:60D5  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:60D7  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   71                     	stw <_bx,video_data
       01:60D9  A5 FA     	lda	LOW_BYTE <_bx
       01:60DB  8D 02 00  	sta	LOW_BYTE video_data
       01:60DE  A5 FB     	lda	HIGH_BYTE <_bx
       01:60E0  8D 03 00  	sta	HIGH_BYTE video_data
   72                     	;lower right corner
   73                     	incw <_bx
       01:60E3  E6 FA     	inc	<_bx		; value at stated memory
       01:60E5  D0 02     	bne	.x_00019		; location
       01:60E7  E6 FB     	inc	<_bx+1
       01:60E9            .x_00019:
   74                     	stw <_bx,video_data
       01:60E9  A5 FA     	lda	LOW_BYTE <_bx
       01:60EB  8D 02 00  	sta	LOW_BYTE video_data
       01:60EE  A5 FB     	lda	HIGH_BYTE <_bx
       01:60F0  8D 03 00  	sta	HIGH_BYTE video_data
   75                     	;restore vram address to where it should be for the next tile
   76                     	subw #$3e,<_di ;each row is $40, so subtracting $3e is like
       01:60F3  38        	sec
       01:60F4  A5 F0     	lda	LOW_BYTE <_di
       01:60F6  E9 3E     	sbc	LOW_BYTE #$3e
       01:60F8  85 F0     	sta	LOW_BYTE <_di
       01:60FA  A5 F1     	lda	HIGH_BYTE <_di
       01:60FC  E9 00     	sbc	HIGH_BYTE #$3e
       01:60FE  85 F1     	sta	HIGH_BYTE <_di
   77                     	vreg #VDC_MAWR ;subtracting $40 and adding $2
       01:6100  A9 00     	lda	#VDC_MAWR
       01:6102  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:6104  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   78                     	stw <_di,video_data
       01:6106  A5 F0     	lda	LOW_BYTE <_di
       01:6108  8D 02 00  	sta	LOW_BYTE video_data
       01:610B  A5 F1     	lda	HIGH_BYTE <_di
       01:610D  8D 03 00  	sta	HIGH_BYTE video_data
   79                     	vreg #VDC_VWR
       01:6110  A9 02     	lda	#VDC_VWR
       01:6112  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:6114  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   80  01:6116  CA        	dex
   81  01:6117  F0 03     	beq .done_row
   82  01:6119  4C 3A 60  	jmp .row_loop
   83  01:611C            .done_row:
   84  01:611C  A5 FE     	lda <_dl
   85  01:611E  3A        	dec a
   86  01:611F  F0 1F     	beq .done
   87  01:6121  85 FE     	sta <_dl
   88                     	addw #(MAP_WIDTH * 2),<_si ;map is 64x32, each tile index is 2 bytes
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6123  18        	clc
       01:6124  A5 EE     	lda	LOW_BYTE <_si
       01:6126  69 40     	adc	LOW_BYTE #(MAP_WIDTH * 2)
       01:6128  85 EE     	sta	LOW_BYTE <_si
       01:612A  A5 EF     	lda	HIGH_BYTE <_si
       01:612C  69 00     	adc	HIGH_BYTE #(MAP_WIDTH * 2)
       01:612E  85 EF     	sta	HIGH_BYTE <_si
                          .endif
   89                     	addw #(MAP_WIDTH * 2),<_di ;skip every other row of the tilemap, plus the remainder
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6130  18        	clc
       01:6131  A5 F0     	lda	LOW_BYTE <_di
       01:6133  69 40     	adc	LOW_BYTE #(MAP_WIDTH * 2)
       01:6135  85 F0     	sta	LOW_BYTE <_di
       01:6137  A5 F1     	lda	HIGH_BYTE <_di
       01:6139  69 00     	adc	HIGH_BYTE #(MAP_WIDTH * 2)
       01:613B  85 F1     	sta	HIGH_BYTE <_di
                          .endif
   90  01:613D  4C 37 60  	jmp .col_loop  ;left over from this tilemap
   91  01:6140            .done:
   92  01:6140  60        	rts
   93                     	
#[1]   main.asm
   46                     	
   47                     	; Player routines
#[2]   player.asm
   48                     	.include "player.asm"
    1                     ; player.asm: Player movement code
    2                     ; Copyright (C) 2020 Nathan Misner
    3                     
    4                     ; This program is free software; you can redistribute it and/or
    5                     ; modify it under the terms of version 2 of the GNU General Public
    6                     ; License as published by the Free Software Foundation.
    7                     
    8                     ; This program is distributed in the hope that it will be useful,
    9                     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   10                     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   11                     ; GNU General Public License for more details.
   12                     
   13                     ; You should have received a copy of the GNU General Public License
   14                     ; along with this program; if not, see
   15                     ; <https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>
   18           E000      	.data
   19           0001      	.bank 1
   20           6141      	.code
   21                     
   22           0400      TOP_SPEED .equ $400
   23           0080      ACCEL .equ $80
   24           0098      PLAYERSPR_X .equ 152 ;onscreen sprite position
   25           00A0      PLAYERSPR_Y .equ 160
   26           0010      PLAYER_WIDTH .equ 16
   27           0020      PLAYER_HEIGHT .equ 32
   28           0000      STATE_GROUND .equ 0
   29           0001      STATE_AIR .equ 1
   30                     
   31  01:6141            player_init:
   32                     	;write player sprite to satb
   33                     	stw #PLAYERSPR_Y,satb ;y pos
       01:6141  A9 A0     	lda	LOW_BYTE #PLAYERSPR_Y
       01:6143  8D 7C 26  	sta	LOW_BYTE satb
       01:6146  A9 00     	lda	HIGH_BYTE #PLAYERSPR_Y
       01:6148  8D 7D 26  	sta	HIGH_BYTE satb
   34                     	stw #PLAYERSPR_X,satb+2 ;x pos
       01:614B  A9 98     	lda	LOW_BYTE #PLAYERSPR_X
       01:614D  8D 7E 26  	sta	LOW_BYTE satb+2
       01:6150  A9 00     	lda	HIGH_BYTE #PLAYERSPR_X
       01:6152  8D 7F 26  	sta	HIGH_BYTE satb+2
   35                     	stw #($3000/32),satb+4 ;tile number
       01:6155  A9 80     	lda	LOW_BYTE #($3000/32)
       01:6157  8D 80 26  	sta	LOW_BYTE satb+4
       01:615A  A9 01     	lda	HIGH_BYTE #($3000/32)
       01:615C  8D 81 26  	sta	HIGH_BYTE satb+4
   36                     	stw	#%0_0_01_0_00_0_1_000_0000,satb+6 ;Attributes
       01:615F  A9 80     	lda	LOW_BYTE #%0_0_01_0_00_0_1_000_0000
       01:6161  8D 82 26  	sta	LOW_BYTE satb+6
       01:6164  A9 10     	lda	HIGH_BYTE #%0_0_01_0_00_0_1_000_0000
       01:6166  8D 83 26  	sta	HIGH_BYTE satb+6
   37                     	stw #PLAYERSPR_X,<player_x+1
       01:6169  A9 98     	lda	LOW_BYTE #PLAYERSPR_X
       01:616B  85 12     	sta	LOW_BYTE <player_x+1
       01:616D  A9 00     	lda	HIGH_BYTE #PLAYERSPR_X
       01:616F  85 13     	sta	HIGH_BYTE <player_x+1
   38                     	stw #PLAYERSPR_Y,<player_y+1
       01:6171  A9 A0     	lda	LOW_BYTE #PLAYERSPR_Y
       01:6173  85 15     	sta	LOW_BYTE <player_y+1
       01:6175  A9 00     	lda	HIGH_BYTE #PLAYERSPR_Y
       01:6177  85 16     	sta	HIGH_BYTE <player_y+1
   39                     	
   40  01:6179  64 1B     	stz <player_state
   41                     	
   42  01:617B  60        	rts
   43                     
   44  01:617C            player_iterate:
   45                     ;-----read input, set initial speed values-----
   46  01:617C  5F 0F 19  	bbr5 <joypad,.done_right
   47                     	cmpw #TOP_SPEED,<player_dx
       01:617F  A5 18     	lda	HIGH_BYTE <player_dx
       01:6181  C9 04     	cmp	HIGH_BYTE #TOP_SPEED
       01:6183  D0 04     	bne	.x_00033
       01:6185  A5 17     	lda	LOW_BYTE <player_dx
       01:6187  C9 00     	cmp	LOW_BYTE #TOP_SPEED
       01:6189            .x_00033:
   48  01:6189  10 0D     	bpl .done_right
   49                     	addw #ACCEL,<player_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:618B  18        	clc
       01:618C  A5 17     	lda	LOW_BYTE <player_dx
       01:618E  69 80     	adc	LOW_BYTE #ACCEL
       01:6190  85 17     	sta	LOW_BYTE <player_dx
       01:6192  A5 18     	lda	HIGH_BYTE <player_dx
       01:6194  69 00     	adc	HIGH_BYTE #ACCEL
       01:6196  85 18     	sta	HIGH_BYTE <player_dx
                          .endif
   50  01:6198            .done_right:
   51  01:6198  7F 0F 1B  	bbr7 <joypad,.done_left
   52                     	cmpw #-TOP_SPEED,<player_dx
       01:619B  A5 18     	lda	HIGH_BYTE <player_dx
       01:619D  C9 FC     	cmp	HIGH_BYTE #-TOP_SPEED
       01:619F  D0 04     	bne	.x_00035
       01:61A1  A5 17     	lda	LOW_BYTE <player_dx
       01:61A3  C9 00     	cmp	LOW_BYTE #-TOP_SPEED
       01:61A5            .x_00035:
   53  01:61A5  30 0F     	bmi .done_left
   54  01:61A7  F0 0D     	beq .done_left
   55                     	subw #ACCEL,<player_dx
       01:61A9  38        	sec
       01:61AA  A5 17     	lda	LOW_BYTE <player_dx
       01:61AC  E9 80     	sbc	LOW_BYTE #ACCEL
       01:61AE  85 17     	sta	LOW_BYTE <player_dx
       01:61B0  A5 18     	lda	HIGH_BYTE <player_dx
       01:61B2  E9 00     	sbc	HIGH_BYTE #ACCEL
       01:61B4  85 18     	sta	HIGH_BYTE <player_dx
   56  01:61B6            .done_left:
   57                     	;deceleration only happens when not pressing left or right
   58  01:61B6  A5 0F     	lda <joypad
   59  01:61B8  29 A0     	and #%10100000
   60  01:61BA  D0 4C     	bne .done_decel
   61                     	cmpw #0,<player_dx
       01:61BC  A5 18     	lda	HIGH_BYTE <player_dx
       01:61BE  C9 00     	cmp	HIGH_BYTE #0
       01:61C0  D0 04     	bne	.x_00037
       01:61C2  A5 17     	lda	LOW_BYTE <player_dx
       01:61C4  C9 00     	cmp	LOW_BYTE #0
       01:61C6            .x_00037:
   62                     	;if player_dx is 0, don't decelerate
   63  01:61C6  F0 40     	beq .done_decel
   64  01:61C8  10 02     	bpl .decel_right
   65  01:61CA  30 1F     	bmi .decel_left
   66  01:61CC            .decel_right:
   67                     	subw #ACCEL,<player_dx
       01:61CC  38        	sec
       01:61CD  A5 17     	lda	LOW_BYTE <player_dx
       01:61CF  E9 80     	sbc	LOW_BYTE #ACCEL
       01:61D1  85 17     	sta	LOW_BYTE <player_dx
       01:61D3  A5 18     	lda	HIGH_BYTE <player_dx
       01:61D5  E9 00     	sbc	HIGH_BYTE #ACCEL
       01:61D7  85 18     	sta	HIGH_BYTE <player_dx
   68                     	;if value goes under zero, make it zero
   69                     	cmpw #0,<player_dx
       01:61D9  A5 18     	lda	HIGH_BYTE <player_dx
       01:61DB  C9 00     	cmp	HIGH_BYTE #0
       01:61DD  D0 04     	bne	.x_00039
       01:61DF  A5 17     	lda	LOW_BYTE <player_dx
       01:61E1  C9 00     	cmp	LOW_BYTE #0
       01:61E3            .x_00039:
   70  01:61E3  10 04     	bpl .dont_zero_right
   71                     	stwz <player_dx
       01:61E5  64 17     	stz	LOW_BYTE <player_dx
       01:61E7  64 18     	stz	HIGH_BYTE <player_dx
   72  01:61E9            .dont_zero_right:
   73  01:61E9  80 1D     	bra .done_decel
   74  01:61EB            .decel_left:
   75                     	addw #ACCEL,<player_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:61EB  18        	clc
       01:61EC  A5 17     	lda	LOW_BYTE <player_dx
       01:61EE  69 80     	adc	LOW_BYTE #ACCEL
       01:61F0  85 17     	sta	LOW_BYTE <player_dx
       01:61F2  A5 18     	lda	HIGH_BYTE <player_dx
       01:61F4  69 00     	adc	HIGH_BYTE #ACCEL
       01:61F6  85 18     	sta	HIGH_BYTE <player_dx
                          .endif
   76                     	; if value goes over zero, make it zero
   77                     	cmpw #0,<player_dx
       01:61F8  A5 18     	lda	HIGH_BYTE <player_dx
       01:61FA  C9 00     	cmp	HIGH_BYTE #0
       01:61FC  D0 04     	bne	.x_00042
       01:61FE  A5 17     	lda	LOW_BYTE <player_dx
       01:6200  C9 00     	cmp	LOW_BYTE #0
       01:6202            .x_00042:
   78  01:6202  30 04     	bmi .done_decel
   79                     	stwz <player_dx
       01:6204  64 17     	stz	LOW_BYTE <player_dx
       01:6206  64 18     	stz	HIGH_BYTE <player_dx
   80  01:6208            .done_decel:
   81                     	;add dx to player_x
   82  01:6208  A5 18     	lda <player_dx+1
   83  01:620A  29 80     	and #%10000000
   84  01:620C  D0 15     	bne .negative_add
   85                     	;positive add
   86                     	addw <player_dx,<player_x
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:620E  18        	clc
       01:620F  A5 11     	lda	LOW_BYTE <player_x
       01:6211  65 17     	adc	LOW_BYTE <player_dx
       01:6213  85 11     	sta	LOW_BYTE <player_x
       01:6215  A5 12     	lda	HIGH_BYTE <player_x
       01:6217  65 18     	adc	HIGH_BYTE <player_dx
       01:6219  85 12     	sta	HIGH_BYTE <player_x
                          .endif
   87  01:621B  A5 13     	lda <player_x+2
   88  01:621D  69 00     	adc #$0
   89  01:621F  85 13     	sta <player_x+2
   90  01:6221  80 13     	bra .done_add
   91  01:6223            .negative_add:
   92                     	addw <player_dx,<player_x
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6223  18        	clc
       01:6224  A5 11     	lda	LOW_BYTE <player_x
       01:6226  65 17     	adc	LOW_BYTE <player_dx
       01:6228  85 11     	sta	LOW_BYTE <player_x
       01:622A  A5 12     	lda	HIGH_BYTE <player_x
       01:622C  65 18     	adc	HIGH_BYTE <player_dx
       01:622E  85 12     	sta	HIGH_BYTE <player_x
                          .endif
   93  01:6230  A5 13     	lda <player_x+2
   94  01:6232  69 FF     	adc #$ff
   95  01:6234  85 13     	sta <player_x+2
   96  01:6236            .done_add:
   97                     ;-----collision detection-----
   98                     ;check left foot
   99                     	stw <player_x+1,<_ax
       01:6236  A5 12     	lda	LOW_BYTE <player_x+1
       01:6238  85 F8     	sta	LOW_BYTE <_ax
       01:623A  A5 13     	lda	HIGH_BYTE <player_x+1
       01:623C  85 F9     	sta	HIGH_BYTE <_ax
  100                     	stw <player_y+1,<_bx
       01:623E  A5 15     	lda	LOW_BYTE <player_y+1
       01:6240  85 FA     	sta	LOW_BYTE <_bx
       01:6242  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6244  85 FB     	sta	HIGH_BYTE <_bx
  101                     	addw #PLAYER_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6246  18        	clc
       01:6247  A5 FA     	lda	LOW_BYTE <_bx
       01:6249  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:624B  85 FA     	sta	LOW_BYTE <_bx
       01:624D  A5 FB     	lda	HIGH_BYTE <_bx
       01:624F  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:6251  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  102  01:6253  20 B8 63  	jsr get_sensor
  103                     	stw <_dx,<pad
       01:6256  A5 FE     	lda	LOW_BYTE <_dx
       01:6258  85 00     	sta	LOW_BYTE <pad
       01:625A  A5 FF     	lda	HIGH_BYTE <_dx
       01:625C  85 01     	sta	HIGH_BYTE <pad
  104                     ;check right foot
  105                     	stw <player_x+1,<_ax
       01:625E  A5 12     	lda	LOW_BYTE <player_x+1
       01:6260  85 F8     	sta	LOW_BYTE <_ax
       01:6262  A5 13     	lda	HIGH_BYTE <player_x+1
       01:6264  85 F9     	sta	HIGH_BYTE <_ax
  106                     	addw #PLAYER_WIDTH,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6266  18        	clc
       01:6267  A5 F8     	lda	LOW_BYTE <_ax
       01:6269  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:626B  85 F8     	sta	LOW_BYTE <_ax
       01:626D  A5 F9     	lda	HIGH_BYTE <_ax
       01:626F  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:6271  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  107                     	stw <player_y+1,<_bx
       01:6273  A5 15     	lda	LOW_BYTE <player_y+1
       01:6275  85 FA     	sta	LOW_BYTE <_bx
       01:6277  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6279  85 FB     	sta	HIGH_BYTE <_bx
  108                     	addw #PLAYER_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:627B  18        	clc
       01:627C  A5 FA     	lda	LOW_BYTE <_bx
       01:627E  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:6280  85 FA     	sta	LOW_BYTE <_bx
       01:6282  A5 FB     	lda	HIGH_BYTE <_bx
       01:6284  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:6286  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  109  01:6288  20 B8 63  	jsr get_sensor
  110                     	cmpw <pad,<_dx
       01:628B  A5 FF     	lda	HIGH_BYTE <_dx
       01:628D  C5 01     	cmp	HIGH_BYTE <pad
       01:628F  D0 04     	bne	.x_00054
       01:6291  A5 FE     	lda	LOW_BYTE <_dx
       01:6293  C5 00     	cmp	LOW_BYTE <pad
       01:6295            .x_00054:
  111  01:6295  30 08     	bmi .left_higher
  112                     	stw <_dx,<pad
       01:6297  A5 FE     	lda	LOW_BYTE <_dx
       01:6299  85 00     	sta	LOW_BYTE <pad
       01:629B  A5 FF     	lda	HIGH_BYTE <_dx
       01:629D  85 01     	sta	HIGH_BYTE <pad
  113  01:629F            .left_higher:
  114                     	cmpw #$0,<player_dy ;don't check for ground collision if moving upwards
       01:629F  A5 1A     	lda	HIGH_BYTE <player_dy
       01:62A1  C9 00     	cmp	HIGH_BYTE #$0
       01:62A3  D0 04     	bne	.x_00056
       01:62A5  A5 19     	lda	LOW_BYTE <player_dy
       01:62A7  C9 00     	cmp	LOW_BYTE #$0
       01:62A9            .x_00056:
  115  01:62A9  30 6A     	bmi .done_ground
  116                     	cmpw #$fff0,<pad ;-16 is the value returned if no ground is found
       01:62AB  A5 01     	lda	HIGH_BYTE <pad
       01:62AD  C9 FF     	cmp	HIGH_BYTE #$fff0
       01:62AF  D0 04     	bne	.x_00057
       01:62B1  A5 00     	lda	LOW_BYTE <pad
       01:62B3  C9 F0     	cmp	LOW_BYTE #$fff0
       01:62B5            .x_00057:
  117  01:62B5  D0 06     	bne .on_ground 
  118  01:62B7  A9 01     	lda #STATE_AIR
  119  01:62B9  85 1B     	sta <player_state
  120  01:62BB  80 58     	bra .done_ground
  121  01:62BD            .on_ground:
  122  01:62BD  A9 00     	lda #STATE_GROUND
  123  01:62BF  85 1B     	sta <player_state
  124                     	stwz <player_dy
       01:62C1  64 19     	stz	LOW_BYTE <player_dy
       01:62C3  64 1A     	stz	HIGH_BYTE <player_dy
  125                     	;foot pos in ax
  126                     	stw <player_y+1,<_ax
       01:62C5  A5 15     	lda	LOW_BYTE <player_y+1
       01:62C7  85 F8     	sta	LOW_BYTE <_ax
       01:62C9  A5 16     	lda	HIGH_BYTE <player_y+1
       01:62CB  85 F9     	sta	HIGH_BYTE <_ax
  127                     	addw #PLAYER_HEIGHT,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62CD  18        	clc
       01:62CE  A5 F8     	lda	LOW_BYTE <_ax
       01:62D0  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:62D2  85 F8     	sta	LOW_BYTE <_ax
       01:62D4  A5 F9     	lda	HIGH_BYTE <_ax
       01:62D6  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:62D8  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  128                     	;place feet at bottom of block
  129                     	andw <_ax,#$fff0
       01:62DA  A5 F8     	lda	LOW_BYTE <_ax
       01:62DC  29 F0     	and LOW_BYTE #$fff0
       01:62DE  85 F8     	sta LOW_BYTE <_ax
       01:62E0  A5 F9     	lda HIGH_BYTE <_ax
       01:62E2  29 FF     	and HIGH_BYTE #$fff0
       01:62E4  85 F9     	sta HIGH_BYTE <_ax
  130                     	addw #16,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62E6  18        	clc
       01:62E7  A5 F8     	lda	LOW_BYTE <_ax
       01:62E9  69 10     	adc	LOW_BYTE #16
       01:62EB  85 F8     	sta	LOW_BYTE <_ax
       01:62ED  A5 F9     	lda	HIGH_BYTE <_ax
       01:62EF  69 00     	adc	HIGH_BYTE #16
       01:62F1  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  131                     	;move up by highest sensor's height
  132                     	subw <pad,<_ax
       01:62F3  38        	sec
       01:62F4  A5 F8     	lda	LOW_BYTE <_ax
       01:62F6  E5 00     	sbc	LOW_BYTE <pad
       01:62F8  85 F8     	sta	LOW_BYTE <_ax
       01:62FA  A5 F9     	lda	HIGH_BYTE <_ax
       01:62FC  E5 01     	sbc	HIGH_BYTE <pad
       01:62FE  85 F9     	sta	HIGH_BYTE <_ax
  133                     	;translate from foot pos to sprite pos
  134                     	subw #PLAYER_HEIGHT,<_ax
       01:6300  38        	sec
       01:6301  A5 F8     	lda	LOW_BYTE <_ax
       01:6303  E9 20     	sbc	LOW_BYTE #PLAYER_HEIGHT
       01:6305  85 F8     	sta	LOW_BYTE <_ax
       01:6307  A5 F9     	lda	HIGH_BYTE <_ax
       01:6309  E9 00     	sbc	HIGH_BYTE #PLAYER_HEIGHT
       01:630B  85 F9     	sta	HIGH_BYTE <_ax
  135                     	stw <_ax,<player_y+1
       01:630D  A5 F8     	lda	LOW_BYTE <_ax
       01:630F  85 15     	sta	LOW_BYTE <player_y+1
       01:6311  A5 F9     	lda	HIGH_BYTE <_ax
       01:6313  85 16     	sta	HIGH_BYTE <player_y+1
  136  01:6315            .done_ground:
  137                     	
  138                     ;-----done collision detection-----
  139                     	stw <player_x+1,<scroll_x
       01:6315  A5 12     	lda	LOW_BYTE <player_x+1
       01:6317  85 08     	sta	LOW_BYTE <scroll_x
       01:6319  A5 13     	lda	HIGH_BYTE <player_x+1
       01:631B  85 09     	sta	HIGH_BYTE <scroll_x
  140                     	subw #PLAYERSPR_X,<scroll_x
       01:631D  38        	sec
       01:631E  A5 08     	lda	LOW_BYTE <scroll_x
       01:6320  E9 98     	sbc	LOW_BYTE #PLAYERSPR_X
       01:6322  85 08     	sta	LOW_BYTE <scroll_x
       01:6324  A5 09     	lda	HIGH_BYTE <scroll_x
       01:6326  E9 00     	sbc	HIGH_BYTE #PLAYERSPR_X
       01:6328  85 09     	sta	HIGH_BYTE <scroll_x
  141                     	
  142                     ;-----jumping & falling-----
  143  01:632A  0F 0F 12  	bbr0 <joypad,.done_one
  144  01:632D  A5 1B     	lda <player_state
  145  01:632F  C9 01     	cmp #STATE_AIR
  146  01:6331  F0 0C     	beq .done_one
  147                     	stw #-($900),<player_dy
       01:6333  A9 00     	lda	LOW_BYTE #-($900)
       01:6335  85 19     	sta	LOW_BYTE <player_dy
       01:6337  A9 F7     	lda	HIGH_BYTE #-($900)
       01:6339  85 1A     	sta	HIGH_BYTE <player_dy
  148  01:633B  A9 01     	lda #STATE_AIR
  149  01:633D  85 1B     	sta <player_state
  150  01:633F            .done_one:	
  151                     	
  152  01:633F  A5 1B     	lda <player_state
  153  01:6341  C9 01     	cmp #STATE_AIR
  154  01:6343  D0 5D     	bne .done_air
  155                     	;jump higher if player's still holding I
  156  01:6345  0F 0F 1B  	bbr0 <joypad,.normal_gravity
  157                     	cmpw #$0,<player_dy
       01:6348  A5 1A     	lda	HIGH_BYTE <player_dy
       01:634A  C9 00     	cmp	HIGH_BYTE #$0
       01:634C  D0 04     	bne	.x_00069
       01:634E  A5 19     	lda	LOW_BYTE <player_dy
       01:6350  C9 00     	cmp	LOW_BYTE #$0
       01:6352            .x_00069:
  158                     	; beq .normal_gravity
  159  01:6352  10 0F     	bpl .normal_gravity
  160                     	addw #$40,<player_dy
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6354  18        	clc
       01:6355  A5 19     	lda	LOW_BYTE <player_dy
       01:6357  69 40     	adc	LOW_BYTE #$40
       01:6359  85 19     	sta	LOW_BYTE <player_dy
       01:635B  A5 1A     	lda	HIGH_BYTE <player_dy
       01:635D  69 00     	adc	HIGH_BYTE #$40
       01:635F  85 1A     	sta	HIGH_BYTE <player_dy
                          .endif
  161  01:6361  80 0D     	bra .done_gravity
  162                     	
  163  01:6363            .normal_gravity:
  164                     	addw #ACCEL,<player_dy
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6363  18        	clc
       01:6364  A5 19     	lda	LOW_BYTE <player_dy
       01:6366  69 80     	adc	LOW_BYTE #ACCEL
       01:6368  85 19     	sta	LOW_BYTE <player_dy
       01:636A  A5 1A     	lda	HIGH_BYTE <player_dy
       01:636C  69 00     	adc	HIGH_BYTE #ACCEL
       01:636E  85 1A     	sta	HIGH_BYTE <player_dy
                          .endif
  165  01:6370            .done_gravity:
  166                     	;add dy to player_y
  167  01:6370  A5 1A     	lda <player_dy+1
  168  01:6372  29 80     	and #%10000000
  169  01:6374  D0 17     	bne .negative_dy
  170                     	;positive add
  171                     	addw <player_dy,<player_y
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6376  18        	clc
       01:6377  A5 14     	lda	LOW_BYTE <player_y
       01:6379  65 19     	adc	LOW_BYTE <player_dy
       01:637B  85 14     	sta	LOW_BYTE <player_y
       01:637D  A5 15     	lda	HIGH_BYTE <player_y
       01:637F  65 1A     	adc	HIGH_BYTE <player_dy
       01:6381  85 15     	sta	HIGH_BYTE <player_y
                          .endif
  172  01:6383  AD 16 20  	lda player_y+2
  173  01:6386  69 00     	adc #$0
  174  01:6388  8D 16 20  	sta player_y+2
  175  01:638B  80 15     	bra .done_air
  176  01:638D            .negative_dy:
  177                     	addw <player_dy,<player_y
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:638D  18        	clc
       01:638E  A5 14     	lda	LOW_BYTE <player_y
       01:6390  65 19     	adc	LOW_BYTE <player_dy
       01:6392  85 14     	sta	LOW_BYTE <player_y
       01:6394  A5 15     	lda	HIGH_BYTE <player_y
       01:6396  65 1A     	adc	HIGH_BYTE <player_dy
       01:6398  85 15     	sta	HIGH_BYTE <player_y
                          .endif
  178  01:639A  AD 16 20  	lda player_y+2
  179  01:639D  69 FF     	adc #$ff
  180  01:639F  8D 16 20  	sta player_y+2
  181  01:63A2            .done_air:
  182                     	stw <player_y+1,<scroll_y
       01:63A2  A5 15     	lda	LOW_BYTE <player_y+1
       01:63A4  85 0A     	sta	LOW_BYTE <scroll_y
       01:63A6  A5 16     	lda	HIGH_BYTE <player_y+1
       01:63A8  85 0B     	sta	HIGH_BYTE <scroll_y
  183                     	subw #PLAYERSPR_Y,<scroll_y
       01:63AA  38        	sec
       01:63AB  A5 0A     	lda	LOW_BYTE <scroll_y
       01:63AD  E9 A0     	sbc	LOW_BYTE #PLAYERSPR_Y
       01:63AF  85 0A     	sta	LOW_BYTE <scroll_y
       01:63B1  A5 0B     	lda	HIGH_BYTE <scroll_y
       01:63B3  E9 00     	sbc	HIGH_BYTE #PLAYERSPR_Y
       01:63B5  85 0B     	sta	HIGH_BYTE <scroll_y
  184  01:63B7  60        	rts
  185                     	
  186                     ;returns number of pixels to move up/down in dx
  187                     ;ax: foot x pos
  188                     ;bx: foot y pos
  189  01:63B8            get_sensor:
  190                     	stw <_ax,<_si
       01:63B8  A5 F8     	lda	LOW_BYTE <_ax
       01:63BA  85 EE     	sta	LOW_BYTE <_si
       01:63BC  A5 F9     	lda	HIGH_BYTE <_ax
       01:63BE  85 EF     	sta	HIGH_BYTE <_si
  191                     	stw <_bx,<_di
       01:63C0  A5 FA     	lda	LOW_BYTE <_bx
       01:63C2  85 F0     	sta	LOW_BYTE <_di
       01:63C4  A5 FB     	lda	HIGH_BYTE <_bx
       01:63C6  85 F1     	sta	HIGH_BYTE <_di
  192  01:63C8  20 38 64  	jsr get_height
  193  01:63CB  85 FE     	sta <_dl
  194  01:63CD  64 FF     	stz <_dh
  195                     	;if height is 0, check below block
  196  01:63CF  F0 06     	beq .check_below
  197  01:63D1  C9 10     	cmp #16
  198                     	;if height is 16, check above block
  199  01:63D3  F0 33     	beq .check_above
  200                     	;otherwise end
  201  01:63D5  80 60     	bra .end
  202  01:63D7            .check_below:
  203                     	;add 16 to height (below tile)
  204                     	stw <_si,<_ax
       01:63D7  A5 EE     	lda	LOW_BYTE <_si
       01:63D9  85 F8     	sta	LOW_BYTE <_ax
       01:63DB  A5 EF     	lda	HIGH_BYTE <_si
       01:63DD  85 F9     	sta	HIGH_BYTE <_ax
  205                     	stw <_di,<_bx
       01:63DF  A5 F0     	lda	LOW_BYTE <_di
       01:63E1  85 FA     	sta	LOW_BYTE <_bx
       01:63E3  A5 F1     	lda	HIGH_BYTE <_di
       01:63E5  85 FB     	sta	HIGH_BYTE <_bx
  206                     	addw #16,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:63E7  18        	clc
       01:63E8  A5 FA     	lda	LOW_BYTE <_bx
       01:63EA  69 10     	adc	LOW_BYTE #16
       01:63EC  85 FA     	sta	LOW_BYTE <_bx
       01:63EE  A5 FB     	lda	HIGH_BYTE <_bx
       01:63F0  69 00     	adc	HIGH_BYTE #16
       01:63F2  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  207  01:63F4  20 38 64  	jsr get_height
  208  01:63F7  85 FE     	sta <_dl
  209                     	;we have to remove 16px from the height
  210                     	subw #16,<_dx
       01:63F9  38        	sec
       01:63FA  A5 FE     	lda	LOW_BYTE <_dx
       01:63FC  E9 10     	sbc	LOW_BYTE #16
       01:63FE  85 FE     	sta	LOW_BYTE <_dx
       01:6400  A5 FF     	lda	HIGH_BYTE <_dx
       01:6402  E9 00     	sbc	HIGH_BYTE #16
       01:6404  85 FF     	sta	HIGH_BYTE <_dx
  211  01:6406  80 2F     	bra .end
  212  01:6408            .check_above:
  213                     	;subtract 16 from height (above tile)
  214                     	stw <_si,<_ax
       01:6408  A5 EE     	lda	LOW_BYTE <_si
       01:640A  85 F8     	sta	LOW_BYTE <_ax
       01:640C  A5 EF     	lda	HIGH_BYTE <_si
       01:640E  85 F9     	sta	HIGH_BYTE <_ax
  215                     	stw <_di,<_bx
       01:6410  A5 F0     	lda	LOW_BYTE <_di
       01:6412  85 FA     	sta	LOW_BYTE <_bx
       01:6414  A5 F1     	lda	HIGH_BYTE <_di
       01:6416  85 FB     	sta	HIGH_BYTE <_bx
  216                     	subw #16,<_bx
       01:6418  38        	sec
       01:6419  A5 FA     	lda	LOW_BYTE <_bx
       01:641B  E9 10     	sbc	LOW_BYTE #16
       01:641D  85 FA     	sta	LOW_BYTE <_bx
       01:641F  A5 FB     	lda	HIGH_BYTE <_bx
       01:6421  E9 00     	sbc	HIGH_BYTE #16
       01:6423  85 FB     	sta	HIGH_BYTE <_bx
  217  01:6425  20 38 64  	jsr get_height
  218  01:6428  85 FE     	sta <_dl
  219                     	;we have to add 16px to the height
  220                     	addw #16,<_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:642A  18        	clc
       01:642B  A5 FE     	lda	LOW_BYTE <_dx
       01:642D  69 10     	adc	LOW_BYTE #16
       01:642F  85 FE     	sta	LOW_BYTE <_dx
       01:6431  A5 FF     	lda	HIGH_BYTE <_dx
       01:6433  69 00     	adc	HIGH_BYTE #16
       01:6435  85 FF     	sta	HIGH_BYTE <_dx
                          .endif
  221  01:6437            .end:
  222  01:6437  60        	rts
  223                     
  224                     
  225                     ;returns height of current tile in al
  226                     ;ax: x pos (pixels)
  227                     ;bx: y pos (pixels)	
  228  01:6438            get_height:
  229                     ;tile offset = ((y >> 4) << 6) + (x >> 4) << 1
  230                     ;            = ((y & #$fff0) << 2) + (x >> 3) & #$fffe
  231                     	;pc engine adds 32 to sprite x positions and 64 to sprite y positions
  232                     	;so origin is 32 pixels left of screen and 64 above
  233                     	subw #32,<_ax
       01:6438  38        	sec
       01:6439  A5 F8     	lda	LOW_BYTE <_ax
       01:643B  E9 20     	sbc	LOW_BYTE #32
       01:643D  85 F8     	sta	LOW_BYTE <_ax
       01:643F  A5 F9     	lda	HIGH_BYTE <_ax
       01:6441  E9 00     	sbc	HIGH_BYTE #32
       01:6443  85 F9     	sta	HIGH_BYTE <_ax
  234                     	subw #64,<_bx
       01:6445  38        	sec
       01:6446  A5 FA     	lda	LOW_BYTE <_bx
       01:6448  E9 40     	sbc	LOW_BYTE #64
       01:644A  85 FA     	sta	LOW_BYTE <_bx
       01:644C  A5 FB     	lda	HIGH_BYTE <_bx
       01:644E  E9 00     	sbc	HIGH_BYTE #64
       01:6450  85 FB     	sta	HIGH_BYTE <_bx
  235                     	andw <_bx,#$fff0
       01:6452  A5 FA     	lda	LOW_BYTE <_bx
       01:6454  29 F0     	and LOW_BYTE #$fff0
       01:6456  85 FA     	sta LOW_BYTE <_bx
       01:6458  A5 FB     	lda HIGH_BYTE <_bx
       01:645A  29 FF     	and HIGH_BYTE #$fff0
       01:645C  85 FB     	sta HIGH_BYTE <_bx
  236                     	aslw <_bx
       01:645E  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6460  26 FB     	rol	<_bx+1		; memory location)
  237                     	aslw <_bx
       01:6462  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6464  26 FB     	rol	<_bx+1		; memory location)
  238                     	stw <_ax,<_cx
       01:6466  A5 F8     	lda	LOW_BYTE <_ax
       01:6468  85 FC     	sta	LOW_BYTE <_cx
       01:646A  A5 F9     	lda	HIGH_BYTE <_ax
       01:646C  85 FD     	sta	HIGH_BYTE <_cx
  239                     	lsrw <_cx
       01:646E  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:6470  66 FC     	ror	<_cx		; location)
  240                     	lsrw <_cx
       01:6472  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:6474  66 FC     	ror	<_cx		; location)
  241                     	lsrw <_cx
       01:6476  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:6478  66 FC     	ror	<_cx		; location)
  242                     	andw <_cx,#$fffe
       01:647A  A5 FC     	lda	LOW_BYTE <_cx
       01:647C  29 FE     	and LOW_BYTE #$fffe
       01:647E  85 FC     	sta LOW_BYTE <_cx
       01:6480  A5 FD     	lda HIGH_BYTE <_cx
       01:6482  29 FF     	and HIGH_BYTE #$fffe
       01:6484  85 FD     	sta HIGH_BYTE <_cx
  243                     	addw <_cx,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6486  18        	clc
       01:6487  A5 FA     	lda	LOW_BYTE <_bx
       01:6489  65 FC     	adc	LOW_BYTE <_cx
       01:648B  85 FA     	sta	LOW_BYTE <_bx
       01:648D  A5 FB     	lda	HIGH_BYTE <_bx
       01:648F  65 FD     	adc	HIGH_BYTE <_cx
       01:6491  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  244                     	addw #map_load,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6493  18        	clc
       01:6494  A5 FA     	lda	LOW_BYTE <_bx
       01:6496  69 60     	adc	LOW_BYTE #map_load
       01:6498  85 FA     	sta	LOW_BYTE <_bx
       01:649A  A5 FB     	lda	HIGH_BYTE <_bx
       01:649C  69 A0     	adc	HIGH_BYTE #map_load
       01:649E  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  245                     	;<_bx is the pointer to the tile
  246  01:64A0  B2 FA     	lda [<_bx]
  247  01:64A2  AA        	tax
  248                     	;get height array index for the tile
  249  01:64A3  BD 20 A0  	lda heights_load,x
  250  01:64A6  85 FA     	sta <_bl
  251  01:64A8  64 FB     	stz <_bh
  252                     	;each height array is 16 bytes, so shift left by 4 to get the offset
  253                     	aslw <_bx
       01:64AA  06 FA     	asl	<_bx		; word-sized value (at stated
       01:64AC  26 FB     	rol	<_bx+1		; memory location)
  254                     	aslw <_bx
       01:64AE  06 FA     	asl	<_bx		; word-sized value (at stated
       01:64B0  26 FB     	rol	<_bx+1		; memory location)
  255                     	aslw <_bx
       01:64B2  06 FA     	asl	<_bx		; word-sized value (at stated
       01:64B4  26 FB     	rol	<_bx+1		; memory location)
  256                     	aslw <_bx
       01:64B6  06 FA     	asl	<_bx		; word-sized value (at stated
       01:64B8  26 FB     	rol	<_bx+1		; memory location)
  257                     	addw #block_arrs,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:64BA  18        	clc
       01:64BB  A5 FA     	lda	LOW_BYTE <_bx
       01:64BD  69 47     	adc	LOW_BYTE #block_arrs
       01:64BF  85 FA     	sta	LOW_BYTE <_bx
       01:64C1  A5 FB     	lda	HIGH_BYTE <_bx
       01:64C3  69 42     	adc	HIGH_BYTE #block_arrs
       01:64C5  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  258                     	;get offset within the tile
  259  01:64C7  A5 F8     	lda <_al
  260  01:64C9  29 0F     	and #$f
  261  01:64CB  A8        	tay
  262  01:64CC  B1 FA     	lda [<_bx],y
  263  01:64CE  85 F8     	sta <_al
  264  01:64D0  60        	rts
  265                     	
  266                     	
#[1]   main.asm
   49                     
   50                     	;asset location on cd-rom
#[2]   cd_labels.asm
   51                     	.include "cd_labels.asm"
    1                     ;  CD-Rom Data/Overlay reference labels
    2                     ;  Generated by pyDiscMaker Version 1.12
    3                     ; (C) 2019 The DiscMaker Project
    4                     
    5           0000      _ADDR_ipl = 0
    6           1000      _SIZE_ipl = 4096
    7           0002      _SECSIZE_ipl = 2
    8                     
    9           0002      _ADDR_Main_Program = 2
   10           4000      _SIZE_Main_Program = 16384
   11           0008      _SECSIZE_Main_Program = 8
   12                     
   13           000A      _ADDR_spritegfx = 10
   14           2000      _SIZE_spritegfx = 8192
   15           0004      _SECSIZE_spritegfx = 4
   16                     
   17           000E      _ADDR_level1 = 14
   18           4000      _SIZE_level1 = 16384
   19           0008      _SECSIZE_level1 = 8
   20                     
   21           0016      _ADDR__CDROM_Specs_Padding = 22
   22           0000      _SIZE__CDROM_Specs_Padding = 262144
   23           0080      _SECSIZE__CDROM_Specs_Padding = 128
   24                     
#[1]   main.asm
   52                     
   53                     	;-----asset load pointers-----
   54           8000      tile_load equ $8000
   55           A000      pal_load equ $a000 ;palette is 32 bytes
   56           A020      heights_load equ $a020 ;height array indices
   57           A060      map_load equ $a060
   58                     
   59                     	;-----misc constants-----
   60           1000      satb_vram equ $1000 ;where satb is in vram
   61                     
   64           0000      	.data
   65                     
   66           64D1      	.code
   67           0000      	.bank   0
   68           4070      	.org    $4070
   69                     
   70                     ;
   71                     ;
   72                     ;
   73  00:4070            boot:
   74  00:4070  20 99 E0  	jsr     ex_dspoff
   75  00:4073  20 81 E0  	jsr     ex_rcroff
   76  00:4076  20 87 E0  	jsr     ex_irqoff
   77  00:4079  20 30 E0  	jsr     ad_reset
   78                     
   79  00:407C  20 F2 41  	jsr     init_vce
   80                     
   81                     	stw     #boot_video_mode,_ax
       00:407F  A9 22     	lda	LOW_BYTE #boot_video_mode
       00:4081  8D F8 20  	sta	LOW_BYTE _ax
       00:4084  A9 42     	lda	HIGH_BYTE #boot_video_mode
       00:4086  8D F9 20  	sta	HIGH_BYTE _ax
   82  00:4089  20 D7 41  	jsr     init_vdc
   83                     	
   84                     	;set up vsync handler
   85                     	stw #my_vsync,sync_jmp
       00:408C  A9 80     	lda	LOW_BYTE #my_vsync
       00:408E  8D 08 22  	sta	LOW_BYTE sync_jmp
       00:4091  A9 41     	lda	HIGH_BYTE #my_vsync
       00:4093  8D 09 22  	sta	HIGH_BYTE sync_jmp
   86  00:4096  A9 30     	lda #%00110000
   87  00:4098  8D F5 20  	sta irq_m
   88  00:409B  20 96 E0  	jsr ex_dspon
   89  00:409E  20 7E E0  	jsr ex_rcron
   90  00:40A1  20 84 E0  	jsr ex_irqon
   91  00:40A4  20 7B E0  	jsr ex_vsync
   92  00:40A7  20 7B E0  	jsr ex_vsync
   93                     	
   94                     	;initialize zero-page variables
   95  00:40AA  9C 00 20  	stz start_vars
   96  00:40AD  73 00 20  	tii start_vars,start_vars+1,(end_vars-start_vars)
       00:40B0  01 20 1D  
       00:40B3  00        
   97                     	
   98                     	;load sprites
   99                     	cd_load _ADDR_spritegfx,#$68,#_SECSIZE_spritegfx
       00:40B4  64 FC     	stz <_cl ;sector number (bits 24-16)
       00:40B6  A9 00     	lda #HIGH(_ADDR_spritegfx) ;sector number (bits 15-8)
       00:40B8  85 FD     	sta <_ch
       00:40BA  A9 0A     	lda #LOW(_ADDR_spritegfx) ;sector number (bits 7-0)
       00:40BC  85 FE     	sta <_dl
       00:40BE  A9 02     	lda #2 ;write to a bank
       00:40C0  85 FF     	sta <_dh
       00:40C2  A9 68     	lda #$68 ;write starting at bank n
       00:40C4  85 FA     	sta <_bl
       00:40C6  A9 04     	lda #_SECSIZE_spritegfx ;write n sectors
       00:40C8  85 F8     	sta <_al
       00:40CA  20 00 60  	jsr cd_saferead
  100                     	;load level gfx & map
  101                     	cd_load _ADDR_level1,#$82,#_SECSIZE_level1
       00:40CD  64 FC     	stz <_cl ;sector number (bits 24-16)
       00:40CF  A9 00     	lda #HIGH(_ADDR_level1) ;sector number (bits 15-8)
       00:40D1  85 FD     	sta <_ch
       00:40D3  A9 0E     	lda #LOW(_ADDR_level1) ;sector number (bits 7-0)
       00:40D5  85 FE     	sta <_dl
       00:40D7  A9 02     	lda #2 ;write to a bank
       00:40D9  85 FF     	sta <_dh
       00:40DB  A9 82     	lda #$82 ;write starting at bank n
       00:40DD  85 FA     	sta <_bl
       00:40DF  A9 08     	lda #_SECSIZE_level1 ;write n sectors
       00:40E1  85 F8     	sta <_al
       00:40E3  20 00 60  	jsr cd_saferead
  102                     	
  103                     	;play cdda
  104                     	; lda #2 ;track 2
  105                     	; jsr cd_track
  106                     	
  107                     	;copy bg palette
  108                     	stw     #pal_load,<_ax
       00:40E6  A9 00     	lda	LOW_BYTE #pal_load
       00:40E8  85 F8     	sta	LOW_BYTE <_ax
       00:40EA  A9 A0     	lda	HIGH_BYTE #pal_load
       00:40EC  85 F9     	sta	HIGH_BYTE <_ax
  109                     	stw     #$0000,VCE_ADDR_LO
       00:40EE  A9 00     	lda	LOW_BYTE #$0000
       00:40F0  8D 02 04  	sta	LOW_BYTE VCE_ADDR_LO
       00:40F3  A9 00     	lda	HIGH_BYTE #$0000
       00:40F5  8D 03 04  	sta	HIGH_BYTE VCE_ADDR_LO
  110  00:40F8  20 10 42  	jsr     copy_palette
  111                     	
  112                     	;copy bg tiles
  113                     	vreg #VDC_MAWR
       00:40FB  A9 00     	lda	#VDC_MAWR
       00:40FD  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:40FF  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  114                     	stw #$2000,video_data
       00:4101  A9 00     	lda	LOW_BYTE #$2000
       00:4103  8D 02 00  	sta	LOW_BYTE video_data
       00:4106  A9 20     	lda	HIGH_BYTE #$2000
       00:4108  8D 03 00  	sta	HIGH_BYTE video_data
  115                     	vreg #VDC_VWR
       00:410B  A9 02     	lda	#VDC_VWR
       00:410D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:410F  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  116  00:4111  E3 00 80  	tia tile_load,video_data,$2000
       00:4114  02 00 00  
       00:4117  20        
  117                     	; ;copy bg data
  118                     	stw #map_load,<_si
       00:4118  A9 60     	lda	LOW_BYTE #map_load
       00:411A  85 EE     	sta	LOW_BYTE <_si
       00:411C  A9 A0     	lda	HIGH_BYTE #map_load
       00:411E  85 EF     	sta	HIGH_BYTE <_si
  119  00:4120  20 2F 60  	jsr scroll_fill
  120                     	
  121                     	;copy sprite palette
  122  00:4123  A9 68     	lda #$68
  123  00:4125  53 10     	tam #4
  124                     	stw #$8000,<_ax
       00:4127  A9 00     	lda	LOW_BYTE #$8000
       00:4129  85 F8     	sta	LOW_BYTE <_ax
       00:412B  A9 80     	lda	HIGH_BYTE #$8000
       00:412D  85 F9     	sta	HIGH_BYTE <_ax
  125                     	stw #$0100,VCE_ADDR_LO ;sprite palette 0
       00:412F  A9 00     	lda	LOW_BYTE #$0100
       00:4131  8D 02 04  	sta	LOW_BYTE VCE_ADDR_LO
       00:4134  A9 01     	lda	HIGH_BYTE #$0100
       00:4136  8D 03 04  	sta	HIGH_BYTE VCE_ADDR_LO
  126  00:4139  20 10 42  	jsr copy_palette
  127                     	
  128                     	;copy sprite tiles
  129                     	vreg #VDC_MAWR
       00:413C  A9 00     	lda	#VDC_MAWR
       00:413E  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:4140  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  130                     	stw #$3000,video_data
       00:4142  A9 00     	lda	LOW_BYTE #$3000
       00:4144  8D 02 00  	sta	LOW_BYTE video_data
       00:4147  A9 30     	lda	HIGH_BYTE #$3000
       00:4149  8D 03 00  	sta	HIGH_BYTE video_data
  131                     	vreg #VDC_VWR
       00:414C  A9 02     	lda	#VDC_VWR
       00:414E  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:4150  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  132  00:4152  E3 20 80  	tia $8020,video_data,$400
       00:4155  02 00 00  
       00:4158  04        
  133  00:4159  A9 82     	lda #$82
  134  00:415B  53 10     	tam #4
  135                     	
  136                     	;zero out SATB
  137  00:415D  9C 7C 26  	stz satb
  138  00:4160  73 7C 26  	tii satb,satb+1,511
       00:4163  7D 26 FF  
       00:4166  01        
  139                     	
  140  00:4167  20 41 61  	jsr player_init
  141                     	
  142                     	;init scroll
  143                     	stwz <scroll_x
       00:416A  64 08     	stz	LOW_BYTE <scroll_x
       00:416C  64 09     	stz	HIGH_BYTE <scroll_x
  144                     	stwz <scroll_y
       00:416E  64 0A     	stz	LOW_BYTE <scroll_y
       00:4170  64 0B     	stz	HIGH_BYTE <scroll_y
  145                     	
  146                     	;main loop
  147  00:4172            main:
  148                     	; ;d-pad up
  149                     	; bbr4 <joypad,.no_up
  150                     	; decw <scroll_y
  151                     ; .no_up:
  152                     	; ;d-pad right
  153                     	; bbr5 <joypad,.no_right
  154                     	; incw <scroll_x
  155                     ; .no_right:
  156                     	; ;d-pad down
  157                     	; bbr6 <joypad,.no_down
  158                     	; incw <scroll_y
  159                     ; .no_down:
  160                     	; ;d-pad left
  161                     	; bbr7 <joypad,.no_left
  162                     	; decw <scroll_x
  163                     ; .no_left:
  164                     
  165  00:4172  20 7C 61  	jsr player_iterate
  166                     	
  167  00:4175  A9 01     	lda #1
  168  00:4177  85 0C     	sta <status
  169  00:4179            end_loop:
  170                     ;loop until vsync function sets status to 0
  171  00:4179  A5 0C     	lda <status
  172  00:417B  D0 FC     	bne end_loop
  173  00:417D  4C 72 41  	jmp main
  174                     	
  175  00:4180            my_vsync:	
  176                     	incw <frame
       00:4180  E6 0D     	inc	<frame		; value at stated memory
       00:4182  D0 02     	bne	.x_00120		; location
       00:4184  E6 0E     	inc	<frame+1
       00:4186            .x_00120:
  177  00:4186  64 0C     	stz <status
  178                     
  179                     	;set scroll pos
  180                     	vreg #VDC_BXR
       00:4188  A9 07     	lda	#VDC_BXR
       00:418A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:418C  03 07     	st0	#VDC_BXR
                          .else
                          .endif
  181  00:418E  A5 08     	lda <scroll_x
  182                     	stw <scroll_x,video_data
       00:4190  A5 08     	lda	LOW_BYTE <scroll_x
       00:4192  8D 02 00  	sta	LOW_BYTE video_data
       00:4195  A5 09     	lda	HIGH_BYTE <scroll_x
       00:4197  8D 03 00  	sta	HIGH_BYTE video_data
  183                     	vreg #VDC_BYR
       00:419A  A9 08     	lda	#VDC_BYR
       00:419C  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:419E  03 08     	st0	#VDC_BYR
                          .else
                          .endif
  184                     	stw <scroll_y,video_data
       00:41A0  A5 0A     	lda	LOW_BYTE <scroll_y
       00:41A2  8D 02 00  	sta	LOW_BYTE video_data
       00:41A5  A5 0B     	lda	HIGH_BYTE <scroll_y
       00:41A7  8D 03 00  	sta	HIGH_BYTE video_data
  185                     	
  186                     	;copy SATB mirror
  187                     	vreg #VDC_MAWR
       00:41AA  A9 00     	lda	#VDC_MAWR
       00:41AC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41AE  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  188                     	stw #satb_vram,video_data
       00:41B0  A9 00     	lda	LOW_BYTE #satb_vram
       00:41B2  8D 02 00  	sta	LOW_BYTE video_data
       00:41B5  A9 10     	lda	HIGH_BYTE #satb_vram
       00:41B7  8D 03 00  	sta	HIGH_BYTE video_data
  189                     	vreg #VDC_VWR
       00:41BA  A9 02     	lda	#VDC_VWR
       00:41BC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41BE  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  190  00:41C0  E3 7C 26  	tia satb,video_data,512
       00:41C3  02 00 00  
       00:41C6  02        
  191                     	
  192  00:41C7  A9 01     	lda #1 ;read joypad 1
  193  00:41C9  20 63 E0  	jsr ex_joysns
  194  00:41CC  AD 28 22  	lda joy
  195  00:41CF  85 0F     	sta <joypad
  196  00:41D1  AD 2D 22  	lda joytrg
  197  00:41D4  85 10     	sta <joyedge
  198  00:41D6  60        	rts
  199                     	
  200                     ; ***************************************************************************
  201                     ; ***************************************************************************
  202                     ;
  203                     ;
  204                     
  205                     
  206  00:41D7            init_vdc:
  207  00:41D7  08        	php
  208  00:41D8  78        	sei
  209  00:41D9  C2        	cly
  210  00:41DA            .loop:
  211  00:41DA  B1 F8     	lda     [_ax],y
  212  00:41DC  F0 12     	beq     .done
  213  00:41DE  8D 00 00  	sta     VDC_CTRL
  214  00:41E1  C8        	iny
  215  00:41E2  B1 F8     	lda     [_ax],y
  216  00:41E4  8D 02 00  	sta     VDC_DATA_LO
  217  00:41E7  C8        	iny
  218  00:41E8  B1 F8     	lda     [_ax],y
  219  00:41EA  8D 03 00  	sta     VDC_DATA_HI
  220  00:41ED  C8        	iny
  221  00:41EE  80 EA     	bra     .loop
  222  00:41F0            .done:
  223  00:41F0  28        	plp
  224  00:41F1  60        	rts
  225                     
  226                     
  227                     ; ***************************************************************************
  228                     ; ***************************************************************************
  229                     ;
  230                     ;
  231                     
  232  00:41F2            init_vce:
  233  00:41F2  08        	php
  234  00:41F3  78        	sei
  235  00:41F4  9C 02 04  	stz     VCE_ADDR_LO
  236  00:41F7  9C 03 04  	stz     VCE_ADDR_HI
  237  00:41FA  A0 02     	ldy     #$02
  238  00:41FC  82        	clx
  239  00:41FD            .loop:
  240  00:41FD  9C 04 04  	stz     VCE_DATA_LO
  241  00:4200  9C 05 04  	stz     VCE_DATA_HI
  242  00:4203  CA        	dex
  243  00:4204  D0 F7     	bne     .loop
  244  00:4206  88        	dey
  245  00:4207  D0 F4     	bne     .loop
  246  00:4209  A9 00     	lda     #VCE_CR_5MHz
  247  00:420B  8D 00 04  	sta     VCE_CTRL
  248  00:420E  28        	plp
  249  00:420F  60        	rts
  250                     
  251                     
  252                     ; ***************************************************************************
  253                     ; ***************************************************************************
  254                     ;
  255                     ;
  256                     
  257  00:4210            copy_palette:   
  258  00:4210  C2        	cly
  259  00:4211            .loop:
  260  00:4211  B1 F8     	lda     [_ax],y
  261  00:4213  C8        	iny
  262  00:4214  8D 04 04  	sta     VCE_DATA_LO
  263  00:4217  B1 F8     	lda     [_ax],y
  264  00:4219  C8        	iny
  265  00:421A  8D 05 04  	sta     VCE_DATA_HI
  266  00:421D  C0 20     	cpy     #32
  267  00:421F  D0 F0     	bne     .loop
  268  00:4221  60        	rts
  269                     
  270                     
  271                     ; ***************************************************************************
  272                     ; ***************************************************************************
  273                     
  274                     ; VDC constants for 240 & 256 wide display.
  275                     
  276           0000      VCE_CR_5MHz  = $00
  277                     
  278           0302      VDC_HSR_240  = $0302
  279           041D      VDC_HDR_240  = $041D
  280                     
  281           0202      VDC_HSR_256  = $0202
  282           041F      VDC_HDR_256  = $041F
  283                     
  284                     ; VDC constants for 320 & 336 wide display.
  285                     
  286           0001      VCE_CR_7MHz  = $01
  287                     
  288           0502      VDC_HSR_320  = $0502
  289           0427      VDC_HDR_320  = $0427
  290                     
  291           0402      VDC_HSR_336  = $0402
  292           0429      VDC_HDR_336  = $0429
  293                     
  294                     ; VDC constants for 480 & 512 wide display.
  295                     
  296           0002      VCE_CR_10MHz = $02
  297                     
  298           0C02      VDC_HSR_480  = $0C02
  299           043C      VDC_HDR_480  = $043C
  300                     
  301           0B02      VDC_HSR_512  = $0B02
  302           043F      VDC_HDR_512  = $043F
  303                     
  304                     ; VDC constants for 200, 224 & 240 high display.
  305                     
  306           2302      VDC_VPR_200  = $2302
  307           00C7      VDC_VDW_200  = $00C7
  308           0018      VDC_VCR_200  = $0018
  309                     
  310           1702      VDC_VPR_224  = $1702
  311           00DF      VDC_VDW_224  = $00DF
  312           000C      VDC_VCR_224  = $000C
  313                     
  314           0F02      VDC_VPR_240  = $0F02
  315           00EF      VDC_VDW_240  = $00EF
  316           0004      VDC_VCR_240  = $0004 ; $00F6
  317                     
  318                     ; VDC constants for different BAT screen sizes.
  319                     
  320           0000      VDC_MWR_32x32  = $0000
  321           0040      VDC_MWR_32x64  = $0040
  322                     
  323           0010      VDC_MWR_64x32  = $0010
  324           0050      VDC_MWR_64x64  = $0050
  325                     
  326           0020      VDC_MWR_128x32 = $0020
  327           0060      VDC_MWR_128x64 = $0060
  328                     
  329                     ; Table of VDC values to set on boot.
  330                     
  331  00:4222            boot_video_mode:
  332  00:4222  05        	.db     VDC_CR                  ; Control Register
  333  00:4223  00 00     	.dw     $0000
  334  00:4225  06        	.db     VDC_RCR                 ; Raster Counter Register
  335  00:4226  00 00     	.dw     $0000
  336  00:4228  07        	.db     VDC_BXR                 ; Background X-Scroll Register
  337  00:4229  00 00     	.dw     $0000
  338  00:422B  08        	.db     VDC_BYR                 ; Background Y-Scroll Register
  339  00:422C  00 00     	.dw     $0000
  340  00:422E  09        	.db     VDC_MWR                 ; Memory-access Width Register
  341  00:422F  50 00     	.dw     VDC_MWR_64x64
  342  00:4231  0A        	.db     VDC_HSR                 ; Horizontal Sync Register
  343  00:4232  02 02     	.dw     VDC_HSR_256
  344  00:4234  0B        	.db     VDC_HDR                 ; Horizontal Display Register
  345  00:4235  1F 04     	.dw     VDC_HDR_256
  346  00:4237  0C        	.db     VDC_VPR                 ; Vertical Sync Register
  347  00:4238  02 17     	.dw     VDC_VPR_224
  348  00:423A  0D        	.db     VDC_VDW                 ; Vertical Display Register
  349  00:423B  DF 00     	.dw     VDC_VDW_224
  350  00:423D  0E        	.db     VDC_VCR                 ; Vertical Display END position Register
  351  00:423E  0C 00     	.dw     VDC_VCR_224
  352  00:4240  0F        	.db     VDC_DCR                 ; DMA Control Register
  353  00:4241  10 00     	.dw     $0010
  354  00:4243  13        	.db     VDC_SATB                ; SATB  address of the SATB
  355  00:4244  00 10     	.dw     satb_vram
  356  00:4246  00        	.db     0
  357                     
  358                     ;block height arrays
#[2]   blocks.asm
  359                     	.include "blocks.asm"
    1                     ; blocks.asm: Block height arrays
    2                     ; Copyright (C) 2020 Nathan Misner
    3                     
    4                     ; This program is free software; you can redistribute it and/or
    5                     ; modify it under the terms of version 2 of the GNU General Public
    6                     ; License as published by the Free Software Foundation.
    7                     
    8                     ; This program is distributed in the hope that it will be useful,
    9                     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   10                     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   11                     ; GNU General Public License for more details.
   12                     
   13                     ; You should have received a copy of the GNU General Public License
   14                     ; along with this program; if not, see
   15                     ; <https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>
   16                     
   17           4247      	.code
   18           0000      	.bank 0
   19  00:4247            block_arrs:
   20                     ;empty block
   21  00:4247            HeightEmpty:
   22  00:4247  00 00 00  	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       00:424A  00 00 00  
       00:424D  00 00 00  
       00:4250  00 00 00  
       00:4253  00 00 00  
       00:4256  00        
   23                     	
   24                     ;full block
   25  00:4257            HeightFull:
   26  00:4257  10 10 10  	.db 16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
       00:425A  10 10 10  
       00:425D  10 10 10  
       00:4260  10 10 10  
       00:4263  10 10 10  
       00:4266  10        
   27                     	
   28                     ;45 degree
   29  00:4267            Height45:
   30  00:4267  00 01 02  	.db 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
       00:426A  03 04 05  
       00:426D  06 07 08  
       00:4270  09 0A 0B  
       00:4273  0C 0D 0E  
       00:4276  0F        
   31                     	
   32                     ;45 degree reversed
   33  00:4277            Height45R:
   34  00:4277  0F 0E 0D  	.db 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
       00:427A  0C 0B 0A  
       00:427D  09 08 07  
       00:4280  06 05 04  
       00:4283  03 02 01  
       00:4286  00        
   35                     	
   36                     ;22.5 degree part 1
   37  00:4287            Height2251:
   38  00:4287  00 00 01  	.db 0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7
       00:428A  01 02 02  
       00:428D  03 03 04  
       00:4290  04 05 05  
       00:4293  06 06 07  
       00:4296  07        
   39                     	
   40                     ;22.5 degree part 1 reversed
   41  00:4297            Height2251R:
   42  00:4297  07 07 06  	.db 7,7,6,6,5,5,4,4,3,3,2,2,1,1,0,0
       00:429A  06 05 05  
       00:429D  04 04 03  
       00:42A0  03 02 02  
       00:42A3  01 01 00  
       00:42A6  00        
   43                     	
   44                     ;22.5 degree part 2
   45  00:42A7            Height2252:
   46  00:42A7  08 08 09  	.db 8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15
       00:42AA  09 0A 0A  
       00:42AD  0B 0B 0C  
       00:42B0  0C 0D 0D  
       00:42B3  0E 0E 0F  
       00:42B6  0F        
   47                     	
   48                     ;22.5 degree part 2 reversed
   49  00:42B7            Height2252R:
   50  00:42B7  0F 0F 0E  	.db 15,15,14,14,13,13,12,12,11,11,10,10,9,9,8,8
       00:42BA  0E 0D 0D  
       00:42BD  0C 0C 0B  
       00:42C0  0B 0A 0A  
       00:42C3  09 09 08  
       00:42C6  08        
   51                     
   52                     	
#[1]   main.asm
  360                     	
