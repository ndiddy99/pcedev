#[1]   main.asm
   18           0001      	.bank 1
   19           602F      	.code
   20                     
   21           000E      NUM_ROWS equ 14 ;14 rows (256x224 resolution, 224/16)
   22           0010      NUM_COLS equ 16 ;16 columns (256x224 resolution, 256/16)
   23           0020      MAP_WIDTH equ 32
   24           0020      MAP_HEIGHT equ 32
   25                     
   26                     ;load a level into vram
   27                     ;_si: map pointer
   28  01:602F            scroll_fill:
   29                     	stwz <_di ;pointer to vram BAT address
       01:602F  64 F0     	stz	LOW_BYTE <_di
       01:6031  64 F1     	stz	HIGH_BYTE <_di
   30  01:6033  A9 20     	lda #MAP_HEIGHT
   31  01:6035  85 FE     	sta <_dl
   32  01:6037            .col_loop:
   33                     ;tile num = (num >> 3) * $20 + (num & 7) * 2
   34                     ;         = ((num & $fff8) << 2) + ((num & 7) << 1)
   35  01:6037  A2 20     	ldx #MAP_WIDTH
   36  01:6039  C2        	cly
   37  01:603A            .row_loop:
   38  01:603A  B1 EE     	lda [<_si],y
   39  01:603C  85 F8     	sta <_al ;_ax is the first "num"
   40                     	;((num & 7) << 1)
   41  01:603E  29 07     	and #$7
   42  01:6040  0A        	asl a
   43  01:6041  85 FA     	sta <_bl ;_bx is the second "num"
   44                     
   45  01:6043  C8        	iny
   46  01:6044  B1 EE     	lda [<_si],y
   47  01:6046  85 F9     	sta <_ah
   48  01:6048  64 FB     	stz <_bh
   49  01:604A  C8        	iny
   50                     	;((num & #$fff8) << 2)
   51                     	andw <_ax,#$fff8
       01:604B  A5 F8     	lda	LOW_BYTE <_ax
       01:604D  29 F8     	and LOW_BYTE #$fff8
       01:604F  85 F8     	sta LOW_BYTE <_ax
       01:6051  A5 F9     	lda HIGH_BYTE <_ax
       01:6053  29 FF     	and HIGH_BYTE #$fff8
       01:6055  85 F9     	sta HIGH_BYTE <_ax
   52                     	aslw <_ax
       01:6057  06 F8     	asl	<_ax		; word-sized value (at stated
       01:6059  26 F9     	rol	<_ax+1		; memory location)
   53                     	aslw <_ax
       01:605B  06 F8     	asl	<_ax		; word-sized value (at stated
       01:605D  26 F9     	rol	<_ax+1		; memory location)
   54                     	addw <_ax,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:605F  18        	clc
       01:6060  A5 FA     	lda	LOW_BYTE <_bx
       01:6062  65 F8     	adc	LOW_BYTE <_ax
       01:6064  85 FA     	sta	LOW_BYTE <_bx
       01:6066  A5 FB     	lda	HIGH_BYTE <_bx
       01:6068  65 F9     	adc	HIGH_BYTE <_ax
       01:606A  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   55                     	addw #$200,<_bx ;tile numbers start at $200
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:606C  18        	clc
       01:606D  A5 FA     	lda	LOW_BYTE <_bx
       01:606F  69 00     	adc	LOW_BYTE #$200
       01:6071  85 FA     	sta	LOW_BYTE <_bx
       01:6073  A5 FB     	lda	HIGH_BYTE <_bx
       01:6075  69 02     	adc	HIGH_BYTE #$200
       01:6077  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   56                     	;correct tile number for upper left corner of 16x16 tile now in _bx
   57                     	vreg #VDC_MAWR
       01:6079  A9 00     	lda	#VDC_MAWR
       01:607B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:607D  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   58                     	stw <_di,video_data
       01:607F  A5 F0     	lda	LOW_BYTE <_di
       01:6081  8D 02 00  	sta	LOW_BYTE video_data
       01:6084  A5 F1     	lda	HIGH_BYTE <_di
       01:6086  8D 03 00  	sta	HIGH_BYTE video_data
   59                     	vreg #VDC_VWR
       01:6089  A9 02     	lda	#VDC_VWR
       01:608B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:608D  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   60                     	stw <_bx,video_data
       01:608F  A5 FA     	lda	LOW_BYTE <_bx
       01:6091  8D 02 00  	sta	LOW_BYTE video_data
       01:6094  A5 FB     	lda	HIGH_BYTE <_bx
       01:6096  8D 03 00  	sta	HIGH_BYTE video_data
   61                     	;upper right corner
   62                     	incw <_bx
       01:6099  E6 FA     	inc	<_bx		; value at stated memory
       01:609B  D0 02     	bne	.x_00011		; location
       01:609D  E6 FB     	inc	<_bx+1
       01:609F            .x_00011:
   63                     	stw <_bx,video_data
       01:609F  A5 FA     	lda	LOW_BYTE <_bx
       01:60A1  8D 02 00  	sta	LOW_BYTE video_data
       01:60A4  A5 FB     	lda	HIGH_BYTE <_bx
       01:60A6  8D 03 00  	sta	HIGH_BYTE video_data
   64                     	;lower left corner
   65                     	addw #$f,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:60A9  18        	clc
       01:60AA  A5 FA     	lda	LOW_BYTE <_bx
       01:60AC  69 0F     	adc	LOW_BYTE #$f
       01:60AE  85 FA     	sta	LOW_BYTE <_bx
       01:60B0  A5 FB     	lda	HIGH_BYTE <_bx
       01:60B2  69 00     	adc	HIGH_BYTE #$f
       01:60B4  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   66                     	;screen is on next row (64x64 tilemap)
   67                     	addw #$40,<_di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:60B6  18        	clc
       01:60B7  A5 F0     	lda	LOW_BYTE <_di
       01:60B9  69 40     	adc	LOW_BYTE #$40
       01:60BB  85 F0     	sta	LOW_BYTE <_di
       01:60BD  A5 F1     	lda	HIGH_BYTE <_di
       01:60BF  69 00     	adc	HIGH_BYTE #$40
       01:60C1  85 F1     	sta	HIGH_BYTE <_di
                          .endif
   68                     	vreg #VDC_MAWR
       01:60C3  A9 00     	lda	#VDC_MAWR
       01:60C5  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:60C7  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   69                     	stw <_di,video_data
       01:60C9  A5 F0     	lda	LOW_BYTE <_di
       01:60CB  8D 02 00  	sta	LOW_BYTE video_data
       01:60CE  A5 F1     	lda	HIGH_BYTE <_di
       01:60D0  8D 03 00  	sta	HIGH_BYTE video_data
   70                     	vreg #VDC_VWR
       01:60D3  A9 02     	lda	#VDC_VWR
       01:60D5  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:60D7  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   71                     	stw <_bx,video_data
       01:60D9  A5 FA     	lda	LOW_BYTE <_bx
       01:60DB  8D 02 00  	sta	LOW_BYTE video_data
       01:60DE  A5 FB     	lda	HIGH_BYTE <_bx
       01:60E0  8D 03 00  	sta	HIGH_BYTE video_data
   72                     	;lower right corner
   73                     	incw <_bx
       01:60E3  E6 FA     	inc	<_bx		; value at stated memory
       01:60E5  D0 02     	bne	.x_00019		; location
       01:60E7  E6 FB     	inc	<_bx+1
       01:60E9            .x_00019:
   74                     	stw <_bx,video_data
       01:60E9  A5 FA     	lda	LOW_BYTE <_bx
       01:60EB  8D 02 00  	sta	LOW_BYTE video_data
       01:60EE  A5 FB     	lda	HIGH_BYTE <_bx
       01:60F0  8D 03 00  	sta	HIGH_BYTE video_data
   75                     	;restore vram address to where it should be for the next tile
   76                     	subw #$3e,<_di ;each row is $40, so subtracting $3e is like
       01:60F3  38        	sec
       01:60F4  A5 F0     	lda	LOW_BYTE <_di
       01:60F6  E9 3E     	sbc	LOW_BYTE #$3e
       01:60F8  85 F0     	sta	LOW_BYTE <_di
       01:60FA  A5 F1     	lda	HIGH_BYTE <_di
       01:60FC  E9 00     	sbc	HIGH_BYTE #$3e
       01:60FE  85 F1     	sta	HIGH_BYTE <_di
   77                     	vreg #VDC_MAWR ;subtracting $40 and adding $2
       01:6100  A9 00     	lda	#VDC_MAWR
       01:6102  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:6104  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   78                     	stw <_di,video_data
       01:6106  A5 F0     	lda	LOW_BYTE <_di
       01:6108  8D 02 00  	sta	LOW_BYTE video_data
       01:610B  A5 F1     	lda	HIGH_BYTE <_di
       01:610D  8D 03 00  	sta	HIGH_BYTE video_data
   79                     	vreg #VDC_VWR
       01:6110  A9 02     	lda	#VDC_VWR
       01:6112  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:6114  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   80  01:6116  CA        	dex
   81  01:6117  F0 03     	beq .done_row
   82  01:6119  4C 3A 60  	jmp .row_loop
   83  01:611C            .done_row:
   84  01:611C  A5 FE     	lda <_dl
   85  01:611E  3A        	dec a
   86  01:611F  F0 1F     	beq .done
   87  01:6121  85 FE     	sta <_dl
   88                     	addw #(MAP_WIDTH * 2),<_si ;map is 64x32, each tile index is 2 bytes
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6123  18        	clc
       01:6124  A5 EE     	lda	LOW_BYTE <_si
       01:6126  69 40     	adc	LOW_BYTE #(MAP_WIDTH * 2)
       01:6128  85 EE     	sta	LOW_BYTE <_si
       01:612A  A5 EF     	lda	HIGH_BYTE <_si
       01:612C  69 00     	adc	HIGH_BYTE #(MAP_WIDTH * 2)
       01:612E  85 EF     	sta	HIGH_BYTE <_si
                          .endif
   89                     	addw #(MAP_WIDTH * 2),<_di ;skip every other row of the tilemap, plus the remainder
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6130  18        	clc
       01:6131  A5 F0     	lda	LOW_BYTE <_di
       01:6133  69 40     	adc	LOW_BYTE #(MAP_WIDTH * 2)
       01:6135  85 F0     	sta	LOW_BYTE <_di
       01:6137  A5 F1     	lda	HIGH_BYTE <_di
       01:6139  69 00     	adc	HIGH_BYTE #(MAP_WIDTH * 2)
       01:613B  85 F1     	sta	HIGH_BYTE <_di
                          .endif
   90  01:613D  4C 37 60  	jmp .col_loop  ;left over from this tilemap
   91  01:6140            .done:
   92  01:6140  60        	rts
   93                     	
#[1]   main.asm
   46                     	
   47                     	; Player routines
#[2]   player.asm
   48                     	.include "player.asm"
    1                     ; player.asm: Player movement code
    2                     ; Copyright (C) 2020 Nathan Misner
    3                     
    4                     ; This program is free software; you can redistribute it and/or
    5                     ; modify it under the terms of version 2 of the GNU General Public
    6                     ; License as published by the Free Software Foundation.
    7                     
    8                     ; This program is distributed in the hope that it will be useful,
    9                     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   10                     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   11                     ; GNU General Public License for more details.
   12                     
   13                     ; You should have received a copy of the GNU General Public License
   14                     ; along with this program; if not, see
   15                     ; <https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>
   18           E000      	.data
   19           0001      	.bank 1
   20           6141      	.code
   21                     
   22           0400      TOP_SPEED .equ $400
   23           0080      ACCEL .equ $80
   24           00A0      GRAVITY .equ $a0
   25           0070      JUMP_GRAVITY .equ $70
   26           0098      PLAYERSPR_X .equ 152 ;onscreen sprite position
   27           00A0      PLAYERSPR_Y .equ 160
   28           0010      PLAYER_WIDTH .equ 16
   29           0020      PLAYER_HEIGHT .equ 32
   30           0008      TSENSOR_HEIGHT .equ 8
   31           0018      BSENSOR_HEIGHT .equ 24
   32           0000      STATE_GROUND .equ 0
   33           0001      STATE_AIR .equ 1
   34                     
   35  01:6141            player_init:
   36                     	;write player sprite to satb
   37                     	stw #PLAYERSPR_Y,satb ;y pos
       01:6141  A9 A0     	lda	LOW_BYTE #PLAYERSPR_Y
       01:6143  8D 7C 26  	sta	LOW_BYTE satb
       01:6146  A9 00     	lda	HIGH_BYTE #PLAYERSPR_Y
       01:6148  8D 7D 26  	sta	HIGH_BYTE satb
   38                     	stw #PLAYERSPR_X,satb+2 ;x pos
       01:614B  A9 98     	lda	LOW_BYTE #PLAYERSPR_X
       01:614D  8D 7E 26  	sta	LOW_BYTE satb+2
       01:6150  A9 00     	lda	HIGH_BYTE #PLAYERSPR_X
       01:6152  8D 7F 26  	sta	HIGH_BYTE satb+2
   39                     	stw #($3000/32),satb+4 ;tile number
       01:6155  A9 80     	lda	LOW_BYTE #($3000/32)
       01:6157  8D 80 26  	sta	LOW_BYTE satb+4
       01:615A  A9 01     	lda	HIGH_BYTE #($3000/32)
       01:615C  8D 81 26  	sta	HIGH_BYTE satb+4
   40                     	stw	#%0_0_01_0_00_0_1_000_0000,satb+6 ;Attributes
       01:615F  A9 80     	lda	LOW_BYTE #%0_0_01_0_00_0_1_000_0000
       01:6161  8D 82 26  	sta	LOW_BYTE satb+6
       01:6164  A9 10     	lda	HIGH_BYTE #%0_0_01_0_00_0_1_000_0000
       01:6166  8D 83 26  	sta	HIGH_BYTE satb+6
   41                     	stw #PLAYERSPR_X,<player_x+1
       01:6169  A9 98     	lda	LOW_BYTE #PLAYERSPR_X
       01:616B  85 12     	sta	LOW_BYTE <player_x+1
       01:616D  A9 00     	lda	HIGH_BYTE #PLAYERSPR_X
       01:616F  85 13     	sta	HIGH_BYTE <player_x+1
   42                     	stw #PLAYERSPR_Y,<player_y+1
       01:6171  A9 A0     	lda	LOW_BYTE #PLAYERSPR_Y
       01:6173  85 15     	sta	LOW_BYTE <player_y+1
       01:6175  A9 00     	lda	HIGH_BYTE #PLAYERSPR_Y
       01:6177  85 16     	sta	HIGH_BYTE <player_y+1
   43                     	
   44  01:6179  64 1B     	stz <player_state
   45                     	
   46  01:617B  60        	rts
   47                     
   48  01:617C            player_iterate:
   49                     ;-----horizontal movement-----
   50  01:617C  5F 0F 19  	bbr5 <joypad,.done_right
   51                     	cmpw #TOP_SPEED,<player_dx
       01:617F  A5 18     	lda	HIGH_BYTE <player_dx
       01:6181  C9 04     	cmp	HIGH_BYTE #TOP_SPEED
       01:6183  D0 04     	bne	.x_00033
       01:6185  A5 17     	lda	LOW_BYTE <player_dx
       01:6187  C9 00     	cmp	LOW_BYTE #TOP_SPEED
       01:6189            .x_00033:
   52  01:6189  10 0D     	bpl .done_right
   53                     	addw #ACCEL,<player_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:618B  18        	clc
       01:618C  A5 17     	lda	LOW_BYTE <player_dx
       01:618E  69 80     	adc	LOW_BYTE #ACCEL
       01:6190  85 17     	sta	LOW_BYTE <player_dx
       01:6192  A5 18     	lda	HIGH_BYTE <player_dx
       01:6194  69 00     	adc	HIGH_BYTE #ACCEL
       01:6196  85 18     	sta	HIGH_BYTE <player_dx
                          .endif
   54  01:6198            .done_right:
   55  01:6198  7F 0F 1B  	bbr7 <joypad,.done_left
   56                     	cmpw #-TOP_SPEED,<player_dx
       01:619B  A5 18     	lda	HIGH_BYTE <player_dx
       01:619D  C9 FC     	cmp	HIGH_BYTE #-TOP_SPEED
       01:619F  D0 04     	bne	.x_00035
       01:61A1  A5 17     	lda	LOW_BYTE <player_dx
       01:61A3  C9 00     	cmp	LOW_BYTE #-TOP_SPEED
       01:61A5            .x_00035:
   57  01:61A5  30 0F     	bmi .done_left
   58  01:61A7  F0 0D     	beq .done_left
   59                     	subw #ACCEL,<player_dx
       01:61A9  38        	sec
       01:61AA  A5 17     	lda	LOW_BYTE <player_dx
       01:61AC  E9 80     	sbc	LOW_BYTE #ACCEL
       01:61AE  85 17     	sta	LOW_BYTE <player_dx
       01:61B0  A5 18     	lda	HIGH_BYTE <player_dx
       01:61B2  E9 00     	sbc	HIGH_BYTE #ACCEL
       01:61B4  85 18     	sta	HIGH_BYTE <player_dx
   60  01:61B6            .done_left:
   61                     	;deceleration only happens when not pressing left or right
   62  01:61B6  A5 0F     	lda <joypad
   63  01:61B8  29 A0     	and #%10100000
   64  01:61BA  D0 4C     	bne .done_decel
   65                     	cmpw #0,<player_dx
       01:61BC  A5 18     	lda	HIGH_BYTE <player_dx
       01:61BE  C9 00     	cmp	HIGH_BYTE #0
       01:61C0  D0 04     	bne	.x_00037
       01:61C2  A5 17     	lda	LOW_BYTE <player_dx
       01:61C4  C9 00     	cmp	LOW_BYTE #0
       01:61C6            .x_00037:
   66                     	;if player_dx is 0, don't decelerate
   67  01:61C6  F0 40     	beq .done_decel
   68  01:61C8  10 02     	bpl .decel_right
   69  01:61CA  30 1F     	bmi .decel_left
   70  01:61CC            .decel_right:
   71                     	subw #ACCEL,<player_dx
       01:61CC  38        	sec
       01:61CD  A5 17     	lda	LOW_BYTE <player_dx
       01:61CF  E9 80     	sbc	LOW_BYTE #ACCEL
       01:61D1  85 17     	sta	LOW_BYTE <player_dx
       01:61D3  A5 18     	lda	HIGH_BYTE <player_dx
       01:61D5  E9 00     	sbc	HIGH_BYTE #ACCEL
       01:61D7  85 18     	sta	HIGH_BYTE <player_dx
   72                     	;if value goes under zero, make it zero
   73                     	cmpw #0,<player_dx
       01:61D9  A5 18     	lda	HIGH_BYTE <player_dx
       01:61DB  C9 00     	cmp	HIGH_BYTE #0
       01:61DD  D0 04     	bne	.x_00039
       01:61DF  A5 17     	lda	LOW_BYTE <player_dx
       01:61E1  C9 00     	cmp	LOW_BYTE #0
       01:61E3            .x_00039:
   74  01:61E3  10 04     	bpl .dont_zero_right
   75                     	stwz <player_dx
       01:61E5  64 17     	stz	LOW_BYTE <player_dx
       01:61E7  64 18     	stz	HIGH_BYTE <player_dx
   76  01:61E9            .dont_zero_right:
   77  01:61E9  80 1D     	bra .done_decel
   78  01:61EB            .decel_left:
   79                     	addw #ACCEL,<player_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:61EB  18        	clc
       01:61EC  A5 17     	lda	LOW_BYTE <player_dx
       01:61EE  69 80     	adc	LOW_BYTE #ACCEL
       01:61F0  85 17     	sta	LOW_BYTE <player_dx
       01:61F2  A5 18     	lda	HIGH_BYTE <player_dx
       01:61F4  69 00     	adc	HIGH_BYTE #ACCEL
       01:61F6  85 18     	sta	HIGH_BYTE <player_dx
                          .endif
   80                     	; if value goes over zero, make it zero
   81                     	cmpw #0,<player_dx
       01:61F8  A5 18     	lda	HIGH_BYTE <player_dx
       01:61FA  C9 00     	cmp	HIGH_BYTE #0
       01:61FC  D0 04     	bne	.x_00042
       01:61FE  A5 17     	lda	LOW_BYTE <player_dx
       01:6200  C9 00     	cmp	LOW_BYTE #0
       01:6202            .x_00042:
   82  01:6202  30 04     	bmi .done_decel
   83                     	stwz <player_dx
       01:6204  64 17     	stz	LOW_BYTE <player_dx
       01:6206  64 18     	stz	HIGH_BYTE <player_dx
   84  01:6208            .done_decel:
   85                     	;add dx to player_x
   86  01:6208  A5 18     	lda <player_dx+1
   87  01:620A  29 80     	and #%10000000
   88  01:620C  D0 15     	bne .negative_add
   89                     	;positive add
   90                     	addw <player_dx,<player_x
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:620E  18        	clc
       01:620F  A5 11     	lda	LOW_BYTE <player_x
       01:6211  65 17     	adc	LOW_BYTE <player_dx
       01:6213  85 11     	sta	LOW_BYTE <player_x
       01:6215  A5 12     	lda	HIGH_BYTE <player_x
       01:6217  65 18     	adc	HIGH_BYTE <player_dx
       01:6219  85 12     	sta	HIGH_BYTE <player_x
                          .endif
   91  01:621B  A5 13     	lda <player_x+2
   92  01:621D  69 00     	adc #$0
   93  01:621F  85 13     	sta <player_x+2
   94  01:6221  80 13     	bra .done_add
   95  01:6223            .negative_add:
   96                     	addw <player_dx,<player_x
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6223  18        	clc
       01:6224  A5 11     	lda	LOW_BYTE <player_x
       01:6226  65 17     	adc	LOW_BYTE <player_dx
       01:6228  85 11     	sta	LOW_BYTE <player_x
       01:622A  A5 12     	lda	HIGH_BYTE <player_x
       01:622C  65 18     	adc	HIGH_BYTE <player_dx
       01:622E  85 12     	sta	HIGH_BYTE <player_x
                          .endif
   97  01:6230  A5 13     	lda <player_x+2
   98  01:6232  69 FF     	adc #$ff
   99  01:6234  85 13     	sta <player_x+2
  100  01:6236            .done_add:
  101                     ;-----collision detection-----
  102                     	;top left
  103                     	stw <player_x+1,<_ax
       01:6236  A5 12     	lda	LOW_BYTE <player_x+1
       01:6238  85 F8     	sta	LOW_BYTE <_ax
       01:623A  A5 13     	lda	HIGH_BYTE <player_x+1
       01:623C  85 F9     	sta	HIGH_BYTE <_ax
  104                     	stw <player_y+1,<_bx
       01:623E  A5 15     	lda	LOW_BYTE <player_y+1
       01:6240  85 FA     	sta	LOW_BYTE <_bx
       01:6242  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6244  85 FB     	sta	HIGH_BYTE <_bx
  105                     	addw #TSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6246  18        	clc
       01:6247  A5 FA     	lda	LOW_BYTE <_bx
       01:6249  69 08     	adc	LOW_BYTE #TSENSOR_HEIGHT
       01:624B  85 FA     	sta	LOW_BYTE <_bx
       01:624D  A5 FB     	lda	HIGH_BYTE <_bx
       01:624F  69 00     	adc	HIGH_BYTE #TSENSOR_HEIGHT
       01:6251  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  106  01:6253  20 81 65  	jsr get_height
  107  01:6256  F0 03     	beq .nohcollision_left
  108  01:6258  4C E1 62  	jmp .hcollision_left
  109  01:625B            .nohcollision_left
  110                     	;bottom left
  111                     	stw <player_x+1,<_ax
       01:625B  A5 12     	lda	LOW_BYTE <player_x+1
       01:625D  85 F8     	sta	LOW_BYTE <_ax
       01:625F  A5 13     	lda	HIGH_BYTE <player_x+1
       01:6261  85 F9     	sta	HIGH_BYTE <_ax
  112                     	stw <player_y+1,<_bx
       01:6263  A5 15     	lda	LOW_BYTE <player_y+1
       01:6265  85 FA     	sta	LOW_BYTE <_bx
       01:6267  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6269  85 FB     	sta	HIGH_BYTE <_bx
  113                     	addw #BSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:626B  18        	clc
       01:626C  A5 FA     	lda	LOW_BYTE <_bx
       01:626E  69 18     	adc	LOW_BYTE #BSENSOR_HEIGHT
       01:6270  85 FA     	sta	LOW_BYTE <_bx
       01:6272  A5 FB     	lda	HIGH_BYTE <_bx
       01:6274  69 00     	adc	HIGH_BYTE #BSENSOR_HEIGHT
       01:6276  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  114  01:6278  20 81 65  	jsr get_height
  115  01:627B  C9 10     	cmp #$10
  116  01:627D  F0 62     	beq .hcollision_left
  117                     	;top right
  118                     	stw <player_x+1,<_ax
       01:627F  A5 12     	lda	LOW_BYTE <player_x+1
       01:6281  85 F8     	sta	LOW_BYTE <_ax
       01:6283  A5 13     	lda	HIGH_BYTE <player_x+1
       01:6285  85 F9     	sta	HIGH_BYTE <_ax
  119                     	addw #PLAYER_WIDTH,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6287  18        	clc
       01:6288  A5 F8     	lda	LOW_BYTE <_ax
       01:628A  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:628C  85 F8     	sta	LOW_BYTE <_ax
       01:628E  A5 F9     	lda	HIGH_BYTE <_ax
       01:6290  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:6292  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  120                     	stw <player_y+1,<_bx
       01:6294  A5 15     	lda	LOW_BYTE <player_y+1
       01:6296  85 FA     	sta	LOW_BYTE <_bx
       01:6298  A5 16     	lda	HIGH_BYTE <player_y+1
       01:629A  85 FB     	sta	HIGH_BYTE <_bx
  121                     	addw #TSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:629C  18        	clc
       01:629D  A5 FA     	lda	LOW_BYTE <_bx
       01:629F  69 08     	adc	LOW_BYTE #TSENSOR_HEIGHT
       01:62A1  85 FA     	sta	LOW_BYTE <_bx
       01:62A3  A5 FB     	lda	HIGH_BYTE <_bx
       01:62A5  69 00     	adc	HIGH_BYTE #TSENSOR_HEIGHT
       01:62A7  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  122  01:62A9  20 81 65  	jsr get_height
  123  01:62AC  D0 54     	bne .hcollision_right
  124                     	;bottom right
  125                     	stw <player_x+1,<_ax
       01:62AE  A5 12     	lda	LOW_BYTE <player_x+1
       01:62B0  85 F8     	sta	LOW_BYTE <_ax
       01:62B2  A5 13     	lda	HIGH_BYTE <player_x+1
       01:62B4  85 F9     	sta	HIGH_BYTE <_ax
  126                     	addw #PLAYER_WIDTH,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62B6  18        	clc
       01:62B7  A5 F8     	lda	LOW_BYTE <_ax
       01:62B9  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:62BB  85 F8     	sta	LOW_BYTE <_ax
       01:62BD  A5 F9     	lda	HIGH_BYTE <_ax
       01:62BF  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:62C1  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  127                     	stw <player_y+1,<_bx
       01:62C3  A5 15     	lda	LOW_BYTE <player_y+1
       01:62C5  85 FA     	sta	LOW_BYTE <_bx
       01:62C7  A5 16     	lda	HIGH_BYTE <player_y+1
       01:62C9  85 FB     	sta	HIGH_BYTE <_bx
  128                     	addw #BSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62CB  18        	clc
       01:62CC  A5 FA     	lda	LOW_BYTE <_bx
       01:62CE  69 18     	adc	LOW_BYTE #BSENSOR_HEIGHT
       01:62D0  85 FA     	sta	LOW_BYTE <_bx
       01:62D2  A5 FB     	lda	HIGH_BYTE <_bx
       01:62D4  69 00     	adc	HIGH_BYTE #BSENSOR_HEIGHT
       01:62D6  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  129  01:62D8  20 81 65  	jsr get_height
  130  01:62DB  C9 10     	cmp #$10
  131  01:62DD  F0 23     	beq .hcollision_right
  132                     	
  133  01:62DF  80 40     	bra .done_hcollision
  134  01:62E1            .hcollision_left:
  135                     	stwz <player_dx
       01:62E1  64 17     	stz	LOW_BYTE <player_dx
       01:62E3  64 18     	stz	HIGH_BYTE <player_dx
  136                     	andw <player_x+1,#$fff0
       01:62E5  A5 12     	lda	LOW_BYTE <player_x+1
       01:62E7  29 F0     	and LOW_BYTE #$fff0
       01:62E9  85 12     	sta LOW_BYTE <player_x+1
       01:62EB  A5 13     	lda HIGH_BYTE <player_x+1
       01:62ED  29 FF     	and HIGH_BYTE #$fff0
       01:62EF  85 13     	sta HIGH_BYTE <player_x+1
  137                     	addw #$10,<player_x+1
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62F1  18        	clc
       01:62F2  A5 12     	lda	LOW_BYTE <player_x+1
       01:62F4  69 10     	adc	LOW_BYTE #$10
       01:62F6  85 12     	sta	LOW_BYTE <player_x+1
       01:62F8  A5 13     	lda	HIGH_BYTE <player_x+1
       01:62FA  69 00     	adc	HIGH_BYTE #$10
       01:62FC  85 13     	sta	HIGH_BYTE <player_x+1
                          .endif
  138  01:62FE  64 11     	stz <player_x
  139  01:6300  80 1F     	bra .done_hcollision
  140  01:6302            .hcollision_right:
  141                     	stwz <player_dx
       01:6302  64 17     	stz	LOW_BYTE <player_dx
       01:6304  64 18     	stz	HIGH_BYTE <player_dx
  142                     	andw <player_x+1,#$fff0
       01:6306  A5 12     	lda	LOW_BYTE <player_x+1
       01:6308  29 F0     	and LOW_BYTE #$fff0
       01:630A  85 12     	sta LOW_BYTE <player_x+1
       01:630C  A5 13     	lda HIGH_BYTE <player_x+1
       01:630E  29 FF     	and HIGH_BYTE #$fff0
       01:6310  85 13     	sta HIGH_BYTE <player_x+1
  143                     	decw <player_x+1
       01:6312  38        	sec			; value at stated memory
       01:6313  A5 12     	lda	<player_x+1		; location
       01:6315  E9 01     	sbc	#1
       01:6317  85 12     	sta	<player_x+1
       01:6319  A5 13     	lda	<player_x+1+1
       01:631B  E9 00     	sbc	#0
       01:631D  85 13     	sta	<player_x+1+1
  144  01:631F  64 11     	stz <player_x
  145  01:6321            .done_hcollision:	
  146                     ;-----jumping & falling-----
  147  01:6321  0F 10 12  	bbr0 <joyedge,.done_one ;handle jump button press
  148  01:6324  A5 1B     	lda <player_state
  149  01:6326  C9 01     	cmp #STATE_AIR
  150  01:6328  F0 0C     	beq .done_one
  151                     	stw #-($900),<player_dy
       01:632A  A9 00     	lda	LOW_BYTE #-($900)
       01:632C  85 19     	sta	LOW_BYTE <player_dy
       01:632E  A9 F7     	lda	HIGH_BYTE #-($900)
       01:6330  85 1A     	sta	HIGH_BYTE <player_dy
  152  01:6332  A9 01     	lda #STATE_AIR
  153  01:6334  85 1B     	sta <player_state
  154  01:6336            .done_one:	
  155                     	
  156  01:6336  A5 1B     	lda <player_state
  157  01:6338  C9 01     	cmp #STATE_AIR
  158  01:633A  D0 5D     	bne .done_air
  159                     	;jump higher if player's still holding I
  160  01:633C  0F 0F 1B  	bbr0 <joypad,.normal_gravity
  161                     	cmpw #$0,<player_dy
       01:633F  A5 1A     	lda	HIGH_BYTE <player_dy
       01:6341  C9 00     	cmp	HIGH_BYTE #$0
       01:6343  D0 04     	bne	.x_00067
       01:6345  A5 19     	lda	LOW_BYTE <player_dy
       01:6347  C9 00     	cmp	LOW_BYTE #$0
       01:6349            .x_00067:
  162  01:6349  10 0F     	bpl .normal_gravity
  163                     	addw #JUMP_GRAVITY,<player_dy
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:634B  18        	clc
       01:634C  A5 19     	lda	LOW_BYTE <player_dy
       01:634E  69 70     	adc	LOW_BYTE #JUMP_GRAVITY
       01:6350  85 19     	sta	LOW_BYTE <player_dy
       01:6352  A5 1A     	lda	HIGH_BYTE <player_dy
       01:6354  69 00     	adc	HIGH_BYTE #JUMP_GRAVITY
       01:6356  85 1A     	sta	HIGH_BYTE <player_dy
                          .endif
  164  01:6358  80 0D     	bra .done_gravity
  165                     	
  166  01:635A            .normal_gravity:
  167                     	addw #GRAVITY,<player_dy
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:635A  18        	clc
       01:635B  A5 19     	lda	LOW_BYTE <player_dy
       01:635D  69 A0     	adc	LOW_BYTE #GRAVITY
       01:635F  85 19     	sta	LOW_BYTE <player_dy
       01:6361  A5 1A     	lda	HIGH_BYTE <player_dy
       01:6363  69 00     	adc	HIGH_BYTE #GRAVITY
       01:6365  85 1A     	sta	HIGH_BYTE <player_dy
                          .endif
  168  01:6367            .done_gravity:
  169                     	;add dy to player_y
  170  01:6367  A5 1A     	lda <player_dy+1
  171  01:6369  29 80     	and #%10000000
  172  01:636B  D0 17     	bne .negative_dy
  173                     	;positive add
  174                     	addw <player_dy,<player_y
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:636D  18        	clc
       01:636E  A5 14     	lda	LOW_BYTE <player_y
       01:6370  65 19     	adc	LOW_BYTE <player_dy
       01:6372  85 14     	sta	LOW_BYTE <player_y
       01:6374  A5 15     	lda	HIGH_BYTE <player_y
       01:6376  65 1A     	adc	HIGH_BYTE <player_dy
       01:6378  85 15     	sta	HIGH_BYTE <player_y
                          .endif
  175  01:637A  AD 16 20  	lda player_y+2
  176  01:637D  69 00     	adc #$0
  177  01:637F  8D 16 20  	sta player_y+2
  178  01:6382  80 15     	bra .done_air
  179  01:6384            .negative_dy:
  180                     	addw <player_dy,<player_y
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6384  18        	clc
       01:6385  A5 14     	lda	LOW_BYTE <player_y
       01:6387  65 19     	adc	LOW_BYTE <player_dy
       01:6389  85 14     	sta	LOW_BYTE <player_y
       01:638B  A5 15     	lda	HIGH_BYTE <player_y
       01:638D  65 1A     	adc	HIGH_BYTE <player_dy
       01:638F  85 15     	sta	HIGH_BYTE <player_y
                          .endif
  181  01:6391  AD 16 20  	lda player_y+2
  182  01:6394  69 FF     	adc #$ff
  183  01:6396  8D 16 20  	sta player_y+2
  184  01:6399            .done_air:
  185                     	
  186                     ;-----collision detection-----
  187                     	cmpw #$0,<player_dy ;don't check for ground collision if moving upwards
       01:6399  A5 1A     	lda	HIGH_BYTE <player_dy
       01:639B  C9 00     	cmp	HIGH_BYTE #$0
       01:639D  D0 04     	bne	.x_00072
       01:639F  A5 19     	lda	LOW_BYTE <player_dy
       01:63A1  C9 00     	cmp	LOW_BYTE #$0
       01:63A3            .x_00072:
  188  01:63A3  10 05     	bpl .floor_collision
  189  01:63A5  F0 03     	beq .floor_collision
  190  01:63A7  4C 80 64  	jmp .ceil_collision
  191                     	
  192  01:63AA            .floor_collision:
  193                     ;check left foot
  194                     	stw <player_x+1,<_ax
       01:63AA  A5 12     	lda	LOW_BYTE <player_x+1
       01:63AC  85 F8     	sta	LOW_BYTE <_ax
       01:63AE  A5 13     	lda	HIGH_BYTE <player_x+1
       01:63B0  85 F9     	sta	HIGH_BYTE <_ax
  195                     	stw <player_y+1,<_bx
       01:63B2  A5 15     	lda	LOW_BYTE <player_y+1
       01:63B4  85 FA     	sta	LOW_BYTE <_bx
       01:63B6  A5 16     	lda	HIGH_BYTE <player_y+1
       01:63B8  85 FB     	sta	HIGH_BYTE <_bx
  196                     	addw #PLAYER_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:63BA  18        	clc
       01:63BB  A5 FA     	lda	LOW_BYTE <_bx
       01:63BD  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:63BF  85 FA     	sta	LOW_BYTE <_bx
       01:63C1  A5 FB     	lda	HIGH_BYTE <_bx
       01:63C3  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:63C5  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  197  01:63C7  20 01 65  	jsr get_sensor
  198                     	stw <_dx,<pad
       01:63CA  A5 FE     	lda	LOW_BYTE <_dx
       01:63CC  85 00     	sta	LOW_BYTE <pad
       01:63CE  A5 FF     	lda	HIGH_BYTE <_dx
       01:63D0  85 01     	sta	HIGH_BYTE <pad
  199                     ;check right foot
  200                     	stw <player_x+1,<_ax
       01:63D2  A5 12     	lda	LOW_BYTE <player_x+1
       01:63D4  85 F8     	sta	LOW_BYTE <_ax
       01:63D6  A5 13     	lda	HIGH_BYTE <player_x+1
       01:63D8  85 F9     	sta	HIGH_BYTE <_ax
  201                     	addw #PLAYER_WIDTH,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:63DA  18        	clc
       01:63DB  A5 F8     	lda	LOW_BYTE <_ax
       01:63DD  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:63DF  85 F8     	sta	LOW_BYTE <_ax
       01:63E1  A5 F9     	lda	HIGH_BYTE <_ax
       01:63E3  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:63E5  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  202                     	stw <player_y+1,<_bx
       01:63E7  A5 15     	lda	LOW_BYTE <player_y+1
       01:63E9  85 FA     	sta	LOW_BYTE <_bx
       01:63EB  A5 16     	lda	HIGH_BYTE <player_y+1
       01:63ED  85 FB     	sta	HIGH_BYTE <_bx
  203                     	addw #PLAYER_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:63EF  18        	clc
       01:63F0  A5 FA     	lda	LOW_BYTE <_bx
       01:63F2  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:63F4  85 FA     	sta	LOW_BYTE <_bx
       01:63F6  A5 FB     	lda	HIGH_BYTE <_bx
       01:63F8  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:63FA  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  204  01:63FC  20 01 65  	jsr get_sensor
  205                     	cmpw <pad,<_dx
       01:63FF  A5 FF     	lda	HIGH_BYTE <_dx
       01:6401  C5 01     	cmp	HIGH_BYTE <pad
       01:6403  D0 04     	bne	.x_00081
       01:6405  A5 FE     	lda	LOW_BYTE <_dx
       01:6407  C5 00     	cmp	LOW_BYTE <pad
       01:6409            .x_00081:
  206  01:6409  30 08     	bmi .left_higher
  207                     	stw <_dx,<pad
       01:640B  A5 FE     	lda	LOW_BYTE <_dx
       01:640D  85 00     	sta	LOW_BYTE <pad
       01:640F  A5 FF     	lda	HIGH_BYTE <_dx
       01:6411  85 01     	sta	HIGH_BYTE <pad
  208  01:6413            .left_higher:
  209                     	cmpw #$fff0,<pad ;-16 is the value returned if no ground is found
       01:6413  A5 01     	lda	HIGH_BYTE <pad
       01:6415  C9 FF     	cmp	HIGH_BYTE #$fff0
       01:6417  D0 04     	bne	.x_00083
       01:6419  A5 00     	lda	LOW_BYTE <pad
       01:641B  C9 F0     	cmp	LOW_BYTE #$fff0
       01:641D            .x_00083:
  210  01:641D  D0 07     	bne .on_ground 
  211  01:641F  A9 01     	lda #STATE_AIR
  212  01:6421  85 1B     	sta <player_state
  213  01:6423  4C D6 64  	jmp .done_ground
  214  01:6426            .on_ground:
  215  01:6426  A9 00     	lda #STATE_GROUND
  216  01:6428  85 1B     	sta <player_state
  217                     	stwz <player_dy
       01:642A  64 19     	stz	LOW_BYTE <player_dy
       01:642C  64 1A     	stz	HIGH_BYTE <player_dy
  218                     	;foot pos in ax
  219                     	stw <player_y+1,<_ax
       01:642E  A5 15     	lda	LOW_BYTE <player_y+1
       01:6430  85 F8     	sta	LOW_BYTE <_ax
       01:6432  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6434  85 F9     	sta	HIGH_BYTE <_ax
  220                     	addw #PLAYER_HEIGHT,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6436  18        	clc
       01:6437  A5 F8     	lda	LOW_BYTE <_ax
       01:6439  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:643B  85 F8     	sta	LOW_BYTE <_ax
       01:643D  A5 F9     	lda	HIGH_BYTE <_ax
       01:643F  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:6441  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  221                     	;place feet at bottom of block
  222                     	andw <_ax,#$fff0
       01:6443  A5 F8     	lda	LOW_BYTE <_ax
       01:6445  29 F0     	and LOW_BYTE #$fff0
       01:6447  85 F8     	sta LOW_BYTE <_ax
       01:6449  A5 F9     	lda HIGH_BYTE <_ax
       01:644B  29 FF     	and HIGH_BYTE #$fff0
       01:644D  85 F9     	sta HIGH_BYTE <_ax
  223                     	addw #16,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:644F  18        	clc
       01:6450  A5 F8     	lda	LOW_BYTE <_ax
       01:6452  69 10     	adc	LOW_BYTE #16
       01:6454  85 F8     	sta	LOW_BYTE <_ax
       01:6456  A5 F9     	lda	HIGH_BYTE <_ax
       01:6458  69 00     	adc	HIGH_BYTE #16
       01:645A  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  224                     	;move up by highest sensor's height
  225                     	subw <pad,<_ax
       01:645C  38        	sec
       01:645D  A5 F8     	lda	LOW_BYTE <_ax
       01:645F  E5 00     	sbc	LOW_BYTE <pad
       01:6461  85 F8     	sta	LOW_BYTE <_ax
       01:6463  A5 F9     	lda	HIGH_BYTE <_ax
       01:6465  E5 01     	sbc	HIGH_BYTE <pad
       01:6467  85 F9     	sta	HIGH_BYTE <_ax
  226                     	;translate from foot pos to sprite pos
  227                     	subw #PLAYER_HEIGHT,<_ax
       01:6469  38        	sec
       01:646A  A5 F8     	lda	LOW_BYTE <_ax
       01:646C  E9 20     	sbc	LOW_BYTE #PLAYER_HEIGHT
       01:646E  85 F8     	sta	LOW_BYTE <_ax
       01:6470  A5 F9     	lda	HIGH_BYTE <_ax
       01:6472  E9 00     	sbc	HIGH_BYTE #PLAYER_HEIGHT
       01:6474  85 F9     	sta	HIGH_BYTE <_ax
  228                     	stw <_ax,<player_y+1
       01:6476  A5 F8     	lda	LOW_BYTE <_ax
       01:6478  85 15     	sta	LOW_BYTE <player_y+1
       01:647A  A5 F9     	lda	HIGH_BYTE <_ax
       01:647C  85 16     	sta	HIGH_BYTE <player_y+1
  229  01:647E  80 56     	bra .done_ground
  230  01:6480            .ceil_collision:
  231                     	;top left
  232                     	stw <player_x+1,<_ax
       01:6480  A5 12     	lda	LOW_BYTE <player_x+1
       01:6482  85 F8     	sta	LOW_BYTE <_ax
       01:6484  A5 13     	lda	HIGH_BYTE <player_x+1
       01:6486  85 F9     	sta	HIGH_BYTE <_ax
  233                     	stw <player_y+1,<_bx
       01:6488  A5 15     	lda	LOW_BYTE <player_y+1
       01:648A  85 FA     	sta	LOW_BYTE <_bx
       01:648C  A5 16     	lda	HIGH_BYTE <player_y+1
       01:648E  85 FB     	sta	HIGH_BYTE <_bx
  234  01:6490  20 81 65  	jsr get_height
  235  01:6493  D0 22     	bne .ceil_rebound
  236                     	;top right
  237                     	stw <player_x+1,<_ax
       01:6495  A5 12     	lda	LOW_BYTE <player_x+1
       01:6497  85 F8     	sta	LOW_BYTE <_ax
       01:6499  A5 13     	lda	HIGH_BYTE <player_x+1
       01:649B  85 F9     	sta	HIGH_BYTE <_ax
  238                     	addw #PLAYER_WIDTH,<_ax	
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:649D  18        	clc
       01:649E  A5 F8     	lda	LOW_BYTE <_ax	
       01:64A0  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:64A2  85 F8     	sta	LOW_BYTE <_ax	
       01:64A4  A5 F9     	lda	HIGH_BYTE <_ax	
       01:64A6  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:64A8  85 F9     	sta	HIGH_BYTE <_ax	
                          .endif
  239                     	stw <player_y+1,<_bx
       01:64AA  A5 15     	lda	LOW_BYTE <player_y+1
       01:64AC  85 FA     	sta	LOW_BYTE <_bx
       01:64AE  A5 16     	lda	HIGH_BYTE <player_y+1
       01:64B0  85 FB     	sta	HIGH_BYTE <_bx
  240  01:64B2  20 81 65  	jsr get_height
  241  01:64B5  F0 1F     	beq .done_ground
  242  01:64B7            .ceil_rebound:
  243                     	stwz <player_dy
       01:64B7  64 19     	stz	LOW_BYTE <player_dy
       01:64B9  64 1A     	stz	HIGH_BYTE <player_dy
  244                     	andw <player_y+1,#$fff0
       01:64BB  A5 15     	lda	LOW_BYTE <player_y+1
       01:64BD  29 F0     	and LOW_BYTE #$fff0
       01:64BF  85 15     	sta LOW_BYTE <player_y+1
       01:64C1  A5 16     	lda HIGH_BYTE <player_y+1
       01:64C3  29 FF     	and HIGH_BYTE #$fff0
       01:64C5  85 16     	sta HIGH_BYTE <player_y+1
  245                     	addw #$10,<player_y+1
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:64C7  18        	clc
       01:64C8  A5 15     	lda	LOW_BYTE <player_y+1
       01:64CA  69 10     	adc	LOW_BYTE #$10
       01:64CC  85 15     	sta	LOW_BYTE <player_y+1
       01:64CE  A5 16     	lda	HIGH_BYTE <player_y+1
       01:64D0  69 00     	adc	HIGH_BYTE #$10
       01:64D2  85 16     	sta	HIGH_BYTE <player_y+1
                          .endif
  246  01:64D4  64 14     	stz <player_y
  247  01:64D6            .done_ground:
  248                     	
  249                     ;-----done collision detection-----
  250                     	stw <player_x+1,<scroll_x
       01:64D6  A5 12     	lda	LOW_BYTE <player_x+1
       01:64D8  85 08     	sta	LOW_BYTE <scroll_x
       01:64DA  A5 13     	lda	HIGH_BYTE <player_x+1
       01:64DC  85 09     	sta	HIGH_BYTE <scroll_x
  251                     	subw #PLAYERSPR_X,<scroll_x	
       01:64DE  38        	sec
       01:64DF  A5 08     	lda	LOW_BYTE <scroll_x	
       01:64E1  E9 98     	sbc	LOW_BYTE #PLAYERSPR_X
       01:64E3  85 08     	sta	LOW_BYTE <scroll_x	
       01:64E5  A5 09     	lda	HIGH_BYTE <scroll_x	
       01:64E7  E9 00     	sbc	HIGH_BYTE #PLAYERSPR_X
       01:64E9  85 09     	sta	HIGH_BYTE <scroll_x	
  252                     	stw <player_y+1,<scroll_y
       01:64EB  A5 15     	lda	LOW_BYTE <player_y+1
       01:64ED  85 0A     	sta	LOW_BYTE <scroll_y
       01:64EF  A5 16     	lda	HIGH_BYTE <player_y+1
       01:64F1  85 0B     	sta	HIGH_BYTE <scroll_y
  253                     	subw #PLAYERSPR_Y,<scroll_y	
       01:64F3  38        	sec
       01:64F4  A5 0A     	lda	LOW_BYTE <scroll_y	
       01:64F6  E9 A0     	sbc	LOW_BYTE #PLAYERSPR_Y
       01:64F8  85 0A     	sta	LOW_BYTE <scroll_y	
       01:64FA  A5 0B     	lda	HIGH_BYTE <scroll_y	
       01:64FC  E9 00     	sbc	HIGH_BYTE #PLAYERSPR_Y
       01:64FE  85 0B     	sta	HIGH_BYTE <scroll_y	
  254  01:6500  60        	rts
  255                     	
  256                     ;returns number of pixels to move up/down in dx
  257                     ;ax: foot x pos
  258                     ;bx: foot y pos
  259  01:6501            get_sensor:
  260                     	stw <_ax,<_si
       01:6501  A5 F8     	lda	LOW_BYTE <_ax
       01:6503  85 EE     	sta	LOW_BYTE <_si
       01:6505  A5 F9     	lda	HIGH_BYTE <_ax
       01:6507  85 EF     	sta	HIGH_BYTE <_si
  261                     	stw <_bx,<_di
       01:6509  A5 FA     	lda	LOW_BYTE <_bx
       01:650B  85 F0     	sta	LOW_BYTE <_di
       01:650D  A5 FB     	lda	HIGH_BYTE <_bx
       01:650F  85 F1     	sta	HIGH_BYTE <_di
  262  01:6511  20 81 65  	jsr get_height
  263  01:6514  85 FE     	sta <_dl
  264  01:6516  64 FF     	stz <_dh
  265                     	;if height is 0, check below block
  266  01:6518  F0 06     	beq .check_below
  267  01:651A  C9 10     	cmp #16
  268                     	;if height is 16, check above block
  269  01:651C  F0 33     	beq .check_above
  270                     	;otherwise end
  271  01:651E  80 60     	bra .end
  272  01:6520            .check_below:
  273                     	;add 16 to height (below tile)
  274                     	stw <_si,<_ax
       01:6520  A5 EE     	lda	LOW_BYTE <_si
       01:6522  85 F8     	sta	LOW_BYTE <_ax
       01:6524  A5 EF     	lda	HIGH_BYTE <_si
       01:6526  85 F9     	sta	HIGH_BYTE <_ax
  275                     	stw <_di,<_bx
       01:6528  A5 F0     	lda	LOW_BYTE <_di
       01:652A  85 FA     	sta	LOW_BYTE <_bx
       01:652C  A5 F1     	lda	HIGH_BYTE <_di
       01:652E  85 FB     	sta	HIGH_BYTE <_bx
  276                     	addw #16,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6530  18        	clc
       01:6531  A5 FA     	lda	LOW_BYTE <_bx
       01:6533  69 10     	adc	LOW_BYTE #16
       01:6535  85 FA     	sta	LOW_BYTE <_bx
       01:6537  A5 FB     	lda	HIGH_BYTE <_bx
       01:6539  69 00     	adc	HIGH_BYTE #16
       01:653B  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  277  01:653D  20 81 65  	jsr get_height
  278  01:6540  85 FE     	sta <_dl
  279                     	;we have to remove 16px from the height
  280                     	subw #16,<_dx
       01:6542  38        	sec
       01:6543  A5 FE     	lda	LOW_BYTE <_dx
       01:6545  E9 10     	sbc	LOW_BYTE #16
       01:6547  85 FE     	sta	LOW_BYTE <_dx
       01:6549  A5 FF     	lda	HIGH_BYTE <_dx
       01:654B  E9 00     	sbc	HIGH_BYTE #16
       01:654D  85 FF     	sta	HIGH_BYTE <_dx
  281  01:654F  80 2F     	bra .end
  282  01:6551            .check_above:
  283                     	;subtract 16 from height (above tile)
  284                     	stw <_si,<_ax
       01:6551  A5 EE     	lda	LOW_BYTE <_si
       01:6553  85 F8     	sta	LOW_BYTE <_ax
       01:6555  A5 EF     	lda	HIGH_BYTE <_si
       01:6557  85 F9     	sta	HIGH_BYTE <_ax
  285                     	stw <_di,<_bx
       01:6559  A5 F0     	lda	LOW_BYTE <_di
       01:655B  85 FA     	sta	LOW_BYTE <_bx
       01:655D  A5 F1     	lda	HIGH_BYTE <_di
       01:655F  85 FB     	sta	HIGH_BYTE <_bx
  286                     	subw #16,<_bx
       01:6561  38        	sec
       01:6562  A5 FA     	lda	LOW_BYTE <_bx
       01:6564  E9 10     	sbc	LOW_BYTE #16
       01:6566  85 FA     	sta	LOW_BYTE <_bx
       01:6568  A5 FB     	lda	HIGH_BYTE <_bx
       01:656A  E9 00     	sbc	HIGH_BYTE #16
       01:656C  85 FB     	sta	HIGH_BYTE <_bx
  287  01:656E  20 81 65  	jsr get_height
  288  01:6571  85 FE     	sta <_dl
  289                     	;we have to add 16px to the height
  290                     	addw #16,<_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6573  18        	clc
       01:6574  A5 FE     	lda	LOW_BYTE <_dx
       01:6576  69 10     	adc	LOW_BYTE #16
       01:6578  85 FE     	sta	LOW_BYTE <_dx
       01:657A  A5 FF     	lda	HIGH_BYTE <_dx
       01:657C  69 00     	adc	HIGH_BYTE #16
       01:657E  85 FF     	sta	HIGH_BYTE <_dx
                          .endif
  291  01:6580            .end:
  292  01:6580  60        	rts
  293                     
  294                     
  295                     ;returns height of current tile in al
  296                     ;ax: x pos (pixels)
  297                     ;bx: y pos (pixels)	
  298  01:6581            get_height:
  299                     ;tile offset = ((y >> 4) << 6) + (x >> 4) << 1
  300                     ;            = ((y & #$fff0) << 2) + (x >> 3) & #$fffe
  301                     	;pc engine adds 32 to sprite x positions and 64 to sprite y positions
  302                     	;so origin is 32 pixels left of screen and 64 above
  303                     	subw #32,<_ax
       01:6581  38        	sec
       01:6582  A5 F8     	lda	LOW_BYTE <_ax
       01:6584  E9 20     	sbc	LOW_BYTE #32
       01:6586  85 F8     	sta	LOW_BYTE <_ax
       01:6588  A5 F9     	lda	HIGH_BYTE <_ax
       01:658A  E9 00     	sbc	HIGH_BYTE #32
       01:658C  85 F9     	sta	HIGH_BYTE <_ax
  304                     	subw #64,<_bx
       01:658E  38        	sec
       01:658F  A5 FA     	lda	LOW_BYTE <_bx
       01:6591  E9 40     	sbc	LOW_BYTE #64
       01:6593  85 FA     	sta	LOW_BYTE <_bx
       01:6595  A5 FB     	lda	HIGH_BYTE <_bx
       01:6597  E9 00     	sbc	HIGH_BYTE #64
       01:6599  85 FB     	sta	HIGH_BYTE <_bx
  305                     	andw <_bx,#$fff0
       01:659B  A5 FA     	lda	LOW_BYTE <_bx
       01:659D  29 F0     	and LOW_BYTE #$fff0
       01:659F  85 FA     	sta LOW_BYTE <_bx
       01:65A1  A5 FB     	lda HIGH_BYTE <_bx
       01:65A3  29 FF     	and HIGH_BYTE #$fff0
       01:65A5  85 FB     	sta HIGH_BYTE <_bx
  306                     	aslw <_bx
       01:65A7  06 FA     	asl	<_bx		; word-sized value (at stated
       01:65A9  26 FB     	rol	<_bx+1		; memory location)
  307                     	aslw <_bx
       01:65AB  06 FA     	asl	<_bx		; word-sized value (at stated
       01:65AD  26 FB     	rol	<_bx+1		; memory location)
  308                     	stw <_ax,<_cx
       01:65AF  A5 F8     	lda	LOW_BYTE <_ax
       01:65B1  85 FC     	sta	LOW_BYTE <_cx
       01:65B3  A5 F9     	lda	HIGH_BYTE <_ax
       01:65B5  85 FD     	sta	HIGH_BYTE <_cx
  309                     	lsrw <_cx
       01:65B7  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:65B9  66 FC     	ror	<_cx		; location)
  310                     	lsrw <_cx
       01:65BB  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:65BD  66 FC     	ror	<_cx		; location)
  311                     	lsrw <_cx
       01:65BF  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:65C1  66 FC     	ror	<_cx		; location)
  312                     	andw <_cx,#$fffe
       01:65C3  A5 FC     	lda	LOW_BYTE <_cx
       01:65C5  29 FE     	and LOW_BYTE #$fffe
       01:65C7  85 FC     	sta LOW_BYTE <_cx
       01:65C9  A5 FD     	lda HIGH_BYTE <_cx
       01:65CB  29 FF     	and HIGH_BYTE #$fffe
       01:65CD  85 FD     	sta HIGH_BYTE <_cx
  313                     	addw <_cx,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:65CF  18        	clc
       01:65D0  A5 FA     	lda	LOW_BYTE <_bx
       01:65D2  65 FC     	adc	LOW_BYTE <_cx
       01:65D4  85 FA     	sta	LOW_BYTE <_bx
       01:65D6  A5 FB     	lda	HIGH_BYTE <_bx
       01:65D8  65 FD     	adc	HIGH_BYTE <_cx
       01:65DA  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  314                     	addw #map_load,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:65DC  18        	clc
       01:65DD  A5 FA     	lda	LOW_BYTE <_bx
       01:65DF  69 60     	adc	LOW_BYTE #map_load
       01:65E1  85 FA     	sta	LOW_BYTE <_bx
       01:65E3  A5 FB     	lda	HIGH_BYTE <_bx
       01:65E5  69 A0     	adc	HIGH_BYTE #map_load
       01:65E7  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  315                     	;<_bx is the pointer to the tile
  316  01:65E9  B2 FA     	lda [<_bx]
  317  01:65EB  AA        	tax
  318                     	;get height array index for the tile
  319  01:65EC  BD 20 A0  	lda heights_load,x
  320  01:65EF  85 FA     	sta <_bl
  321  01:65F1  64 FB     	stz <_bh
  322                     	;each height array is 16 bytes, so shift left by 4 to get the offset
  323                     	aslw <_bx
       01:65F3  06 FA     	asl	<_bx		; word-sized value (at stated
       01:65F5  26 FB     	rol	<_bx+1		; memory location)
  324                     	aslw <_bx
       01:65F7  06 FA     	asl	<_bx		; word-sized value (at stated
       01:65F9  26 FB     	rol	<_bx+1		; memory location)
  325                     	aslw <_bx
       01:65FB  06 FA     	asl	<_bx		; word-sized value (at stated
       01:65FD  26 FB     	rol	<_bx+1		; memory location)
  326                     	aslw <_bx
       01:65FF  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6601  26 FB     	rol	<_bx+1		; memory location)
  327                     	addw #block_arrs,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6603  18        	clc
       01:6604  A5 FA     	lda	LOW_BYTE <_bx
       01:6606  69 47     	adc	LOW_BYTE #block_arrs
       01:6608  85 FA     	sta	LOW_BYTE <_bx
       01:660A  A5 FB     	lda	HIGH_BYTE <_bx
       01:660C  69 42     	adc	HIGH_BYTE #block_arrs
       01:660E  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  328                     	;get offset within the tile
  329  01:6610  A5 F8     	lda <_al
  330  01:6612  29 0F     	and #$f
  331  01:6614  A8        	tay
  332  01:6615  B1 FA     	lda [<_bx],y
  333  01:6617  85 F8     	sta <_al
  334  01:6619  60        	rts
  335                     	
  336                     	
#[1]   main.asm
   49                     
   50                     	;asset location on cd-rom
#[2]   cd_labels.asm
   51                     	.include "cd_labels.asm"
    1                     ;  CD-Rom Data/Overlay reference labels
    2                     ;  Generated by pyDiscMaker Version 1.12
    3                     ; (C) 2019 The DiscMaker Project
    4                     
    5           0000      _ADDR_ipl = 0
    6           1000      _SIZE_ipl = 4096
    7           0002      _SECSIZE_ipl = 2
    8                     
    9           0002      _ADDR_Main_Program = 2
   10           4000      _SIZE_Main_Program = 16384
   11           0008      _SECSIZE_Main_Program = 8
   12                     
   13           000A      _ADDR_spritegfx = 10
   14           2000      _SIZE_spritegfx = 8192
   15           0004      _SECSIZE_spritegfx = 4
   16                     
   17           000E      _ADDR_level1 = 14
   18           4000      _SIZE_level1 = 16384
   19           0008      _SECSIZE_level1 = 8
   20                     
   21           0016      _ADDR__CDROM_Specs_Padding = 22
   22           0000      _SIZE__CDROM_Specs_Padding = 262144
   23           0080      _SECSIZE__CDROM_Specs_Padding = 128
   24                     
#[1]   main.asm
   52                     
   53                     	;-----asset load pointers-----
   54           8000      tile_load equ $8000
   55           A000      pal_load equ $a000 ;palette is 32 bytes
   56           A020      heights_load equ $a020 ;height array indices
   57           A060      map_load equ $a060
   58                     
   59                     	;-----misc constants-----
   60           1000      satb_vram equ $1000 ;where satb is in vram
   61                     
   64           0000      	.data
   65                     
   66           661A      	.code
   67           0000      	.bank   0
   68           4070      	.org    $4070
   69                     
   70                     ;
   71                     ;
   72                     ;
   73  00:4070            boot:
   74  00:4070  20 99 E0  	jsr     ex_dspoff
   75  00:4073  20 81 E0  	jsr     ex_rcroff
   76  00:4076  20 87 E0  	jsr     ex_irqoff
   77  00:4079  20 30 E0  	jsr     ad_reset
   78                     
   79  00:407C  20 F2 41  	jsr     init_vce
   80                     
   81                     	stw     #boot_video_mode,_ax
       00:407F  A9 22     	lda	LOW_BYTE #boot_video_mode
       00:4081  8D F8 20  	sta	LOW_BYTE _ax
       00:4084  A9 42     	lda	HIGH_BYTE #boot_video_mode
       00:4086  8D F9 20  	sta	HIGH_BYTE _ax
   82  00:4089  20 D7 41  	jsr     init_vdc
   83                     	
   84                     	;set up vsync handler
   85                     	stw #my_vsync,sync_jmp
       00:408C  A9 80     	lda	LOW_BYTE #my_vsync
       00:408E  8D 08 22  	sta	LOW_BYTE sync_jmp
       00:4091  A9 41     	lda	HIGH_BYTE #my_vsync
       00:4093  8D 09 22  	sta	HIGH_BYTE sync_jmp
   86  00:4096  A9 30     	lda #%00110000
   87  00:4098  8D F5 20  	sta irq_m
   88  00:409B  20 96 E0  	jsr ex_dspon
   89  00:409E  20 7E E0  	jsr ex_rcron
   90  00:40A1  20 84 E0  	jsr ex_irqon
   91  00:40A4  20 7B E0  	jsr ex_vsync
   92  00:40A7  20 7B E0  	jsr ex_vsync
   93                     	
   94                     	;initialize zero-page variables
   95  00:40AA  9C 00 20  	stz start_vars
   96  00:40AD  73 00 20  	tii start_vars,start_vars+1,(end_vars-start_vars)
       00:40B0  01 20 1D  
       00:40B3  00        
   97                     	
   98                     	;load sprites
   99                     	cd_load _ADDR_spritegfx,#$68,#_SECSIZE_spritegfx
       00:40B4  64 FC     	stz <_cl ;sector number (bits 24-16)
       00:40B6  A9 00     	lda #HIGH(_ADDR_spritegfx) ;sector number (bits 15-8)
       00:40B8  85 FD     	sta <_ch
       00:40BA  A9 0A     	lda #LOW(_ADDR_spritegfx) ;sector number (bits 7-0)
       00:40BC  85 FE     	sta <_dl
       00:40BE  A9 02     	lda #2 ;write to a bank
       00:40C0  85 FF     	sta <_dh
       00:40C2  A9 68     	lda #$68 ;write starting at bank n
       00:40C4  85 FA     	sta <_bl
       00:40C6  A9 04     	lda #_SECSIZE_spritegfx ;write n sectors
       00:40C8  85 F8     	sta <_al
       00:40CA  20 00 60  	jsr cd_saferead
  100                     	;load level gfx & map
  101                     	cd_load _ADDR_level1,#$82,#_SECSIZE_level1
       00:40CD  64 FC     	stz <_cl ;sector number (bits 24-16)
       00:40CF  A9 00     	lda #HIGH(_ADDR_level1) ;sector number (bits 15-8)
       00:40D1  85 FD     	sta <_ch
       00:40D3  A9 0E     	lda #LOW(_ADDR_level1) ;sector number (bits 7-0)
       00:40D5  85 FE     	sta <_dl
       00:40D7  A9 02     	lda #2 ;write to a bank
       00:40D9  85 FF     	sta <_dh
       00:40DB  A9 82     	lda #$82 ;write starting at bank n
       00:40DD  85 FA     	sta <_bl
       00:40DF  A9 08     	lda #_SECSIZE_level1 ;write n sectors
       00:40E1  85 F8     	sta <_al
       00:40E3  20 00 60  	jsr cd_saferead
  102                     	
  103                     	;play cdda
  104                     	; lda #2 ;track 2
  105                     	; jsr cd_track
  106                     	
  107                     	;copy bg palette
  108                     	stw     #pal_load,<_ax
       00:40E6  A9 00     	lda	LOW_BYTE #pal_load
       00:40E8  85 F8     	sta	LOW_BYTE <_ax
       00:40EA  A9 A0     	lda	HIGH_BYTE #pal_load
       00:40EC  85 F9     	sta	HIGH_BYTE <_ax
  109                     	stw     #$0000,VCE_ADDR_LO
       00:40EE  A9 00     	lda	LOW_BYTE #$0000
       00:40F0  8D 02 04  	sta	LOW_BYTE VCE_ADDR_LO
       00:40F3  A9 00     	lda	HIGH_BYTE #$0000
       00:40F5  8D 03 04  	sta	HIGH_BYTE VCE_ADDR_LO
  110  00:40F8  20 10 42  	jsr     copy_palette
  111                     	
  112                     	;copy bg tiles
  113                     	vreg #VDC_MAWR
       00:40FB  A9 00     	lda	#VDC_MAWR
       00:40FD  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:40FF  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  114                     	stw #$2000,video_data
       00:4101  A9 00     	lda	LOW_BYTE #$2000
       00:4103  8D 02 00  	sta	LOW_BYTE video_data
       00:4106  A9 20     	lda	HIGH_BYTE #$2000
       00:4108  8D 03 00  	sta	HIGH_BYTE video_data
  115                     	vreg #VDC_VWR
       00:410B  A9 02     	lda	#VDC_VWR
       00:410D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:410F  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  116  00:4111  E3 00 80  	tia tile_load,video_data,$2000
       00:4114  02 00 00  
       00:4117  20        
  117                     	; ;copy bg data
  118                     	stw #map_load,<_si
       00:4118  A9 60     	lda	LOW_BYTE #map_load
       00:411A  85 EE     	sta	LOW_BYTE <_si
       00:411C  A9 A0     	lda	HIGH_BYTE #map_load
       00:411E  85 EF     	sta	HIGH_BYTE <_si
  119  00:4120  20 2F 60  	jsr scroll_fill
  120                     	
  121                     	;copy sprite palette
  122  00:4123  A9 68     	lda #$68
  123  00:4125  53 10     	tam #4
  124                     	stw #$8000,<_ax
       00:4127  A9 00     	lda	LOW_BYTE #$8000
       00:4129  85 F8     	sta	LOW_BYTE <_ax
       00:412B  A9 80     	lda	HIGH_BYTE #$8000
       00:412D  85 F9     	sta	HIGH_BYTE <_ax
  125                     	stw #$0100,VCE_ADDR_LO ;sprite palette 0
       00:412F  A9 00     	lda	LOW_BYTE #$0100
       00:4131  8D 02 04  	sta	LOW_BYTE VCE_ADDR_LO
       00:4134  A9 01     	lda	HIGH_BYTE #$0100
       00:4136  8D 03 04  	sta	HIGH_BYTE VCE_ADDR_LO
  126  00:4139  20 10 42  	jsr copy_palette
  127                     	
  128                     	;copy sprite tiles
  129                     	vreg #VDC_MAWR
       00:413C  A9 00     	lda	#VDC_MAWR
       00:413E  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:4140  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  130                     	stw #$3000,video_data
       00:4142  A9 00     	lda	LOW_BYTE #$3000
       00:4144  8D 02 00  	sta	LOW_BYTE video_data
       00:4147  A9 30     	lda	HIGH_BYTE #$3000
       00:4149  8D 03 00  	sta	HIGH_BYTE video_data
  131                     	vreg #VDC_VWR
       00:414C  A9 02     	lda	#VDC_VWR
       00:414E  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:4150  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  132  00:4152  E3 20 80  	tia $8020,video_data,$400
       00:4155  02 00 00  
       00:4158  04        
  133  00:4159  A9 82     	lda #$82
  134  00:415B  53 10     	tam #4
  135                     	
  136                     	;zero out SATB
  137  00:415D  9C 7C 26  	stz satb
  138  00:4160  73 7C 26  	tii satb,satb+1,511
       00:4163  7D 26 FF  
       00:4166  01        
  139                     	
  140  00:4167  20 41 61  	jsr player_init
  141                     	
  142                     	;init scroll
  143                     	stwz <scroll_x
       00:416A  64 08     	stz	LOW_BYTE <scroll_x
       00:416C  64 09     	stz	HIGH_BYTE <scroll_x
  144                     	stwz <scroll_y
       00:416E  64 0A     	stz	LOW_BYTE <scroll_y
       00:4170  64 0B     	stz	HIGH_BYTE <scroll_y
  145                     	
  146                     	;main loop
  147  00:4172            main:
  148                     	; ;d-pad up
  149                     	; bbr4 <joypad,.no_up
  150                     	; decw <scroll_y
  151                     ; .no_up:
  152                     	; ;d-pad right
  153                     	; bbr5 <joypad,.no_right
  154                     	; incw <scroll_x
  155                     ; .no_right:
  156                     	; ;d-pad down
  157                     	; bbr6 <joypad,.no_down
  158                     	; incw <scroll_y
  159                     ; .no_down:
  160                     	; ;d-pad left
  161                     	; bbr7 <joypad,.no_left
  162                     	; decw <scroll_x
  163                     ; .no_left:
  164                     
  165  00:4172  20 7C 61  	jsr player_iterate
  166                     	
  167  00:4175  A9 01     	lda #1
  168  00:4177  85 0C     	sta <status
  169  00:4179            end_loop:
  170                     ;loop until vsync function sets status to 0
  171  00:4179  A5 0C     	lda <status
  172  00:417B  D0 FC     	bne end_loop
  173  00:417D  4C 72 41  	jmp main
  174                     	
  175  00:4180            my_vsync:	
  176                     	incw <frame
       00:4180  E6 0D     	inc	<frame		; value at stated memory
       00:4182  D0 02     	bne	.x_00148		; location
       00:4184  E6 0E     	inc	<frame+1
       00:4186            .x_00148:
  177  00:4186  64 0C     	stz <status
  178                     
  179                     	;set scroll pos
  180                     	vreg #VDC_BXR
       00:4188  A9 07     	lda	#VDC_BXR
       00:418A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:418C  03 07     	st0	#VDC_BXR
                          .else
                          .endif
  181  00:418E  A5 08     	lda <scroll_x
  182                     	stw <scroll_x,video_data
       00:4190  A5 08     	lda	LOW_BYTE <scroll_x
       00:4192  8D 02 00  	sta	LOW_BYTE video_data
       00:4195  A5 09     	lda	HIGH_BYTE <scroll_x
       00:4197  8D 03 00  	sta	HIGH_BYTE video_data
  183                     	vreg #VDC_BYR
       00:419A  A9 08     	lda	#VDC_BYR
       00:419C  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:419E  03 08     	st0	#VDC_BYR
                          .else
                          .endif
  184                     	stw <scroll_y,video_data
       00:41A0  A5 0A     	lda	LOW_BYTE <scroll_y
       00:41A2  8D 02 00  	sta	LOW_BYTE video_data
       00:41A5  A5 0B     	lda	HIGH_BYTE <scroll_y
       00:41A7  8D 03 00  	sta	HIGH_BYTE video_data
  185                     	
  186                     	;copy SATB mirror
  187                     	vreg #VDC_MAWR
       00:41AA  A9 00     	lda	#VDC_MAWR
       00:41AC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41AE  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  188                     	stw #satb_vram,video_data
       00:41B0  A9 00     	lda	LOW_BYTE #satb_vram
       00:41B2  8D 02 00  	sta	LOW_BYTE video_data
       00:41B5  A9 10     	lda	HIGH_BYTE #satb_vram
       00:41B7  8D 03 00  	sta	HIGH_BYTE video_data
  189                     	vreg #VDC_VWR
       00:41BA  A9 02     	lda	#VDC_VWR
       00:41BC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41BE  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  190  00:41C0  E3 7C 26  	tia satb,video_data,512
       00:41C3  02 00 00  
       00:41C6  02        
  191                     	
  192  00:41C7  A9 01     	lda #1 ;read joypad 1
  193  00:41C9  20 63 E0  	jsr ex_joysns
  194  00:41CC  AD 28 22  	lda joy
  195  00:41CF  85 0F     	sta <joypad
  196  00:41D1  AD 2D 22  	lda joytrg
  197  00:41D4  85 10     	sta <joyedge
  198  00:41D6  60        	rts
  199                     	
  200                     ; ***************************************************************************
  201                     ; ***************************************************************************
  202                     ;
  203                     ;
  204                     
  205                     
  206  00:41D7            init_vdc:
  207  00:41D7  08        	php
  208  00:41D8  78        	sei
  209  00:41D9  C2        	cly
  210  00:41DA            .loop:
  211  00:41DA  B1 F8     	lda     [_ax],y
  212  00:41DC  F0 12     	beq     .done
  213  00:41DE  8D 00 00  	sta     VDC_CTRL
  214  00:41E1  C8        	iny
  215  00:41E2  B1 F8     	lda     [_ax],y
  216  00:41E4  8D 02 00  	sta     VDC_DATA_LO
  217  00:41E7  C8        	iny
  218  00:41E8  B1 F8     	lda     [_ax],y
  219  00:41EA  8D 03 00  	sta     VDC_DATA_HI
  220  00:41ED  C8        	iny
  221  00:41EE  80 EA     	bra     .loop
  222  00:41F0            .done:
  223  00:41F0  28        	plp
  224  00:41F1  60        	rts
  225                     
  226                     
  227                     ; ***************************************************************************
  228                     ; ***************************************************************************
  229                     ;
  230                     ;
  231                     
  232  00:41F2            init_vce:
  233  00:41F2  08        	php
  234  00:41F3  78        	sei
  235  00:41F4  9C 02 04  	stz     VCE_ADDR_LO
  236  00:41F7  9C 03 04  	stz     VCE_ADDR_HI
  237  00:41FA  A0 02     	ldy     #$02
  238  00:41FC  82        	clx
  239  00:41FD            .loop:
  240  00:41FD  9C 04 04  	stz     VCE_DATA_LO
  241  00:4200  9C 05 04  	stz     VCE_DATA_HI
  242  00:4203  CA        	dex
  243  00:4204  D0 F7     	bne     .loop
  244  00:4206  88        	dey
  245  00:4207  D0 F4     	bne     .loop
  246  00:4209  A9 00     	lda     #VCE_CR_5MHz
  247  00:420B  8D 00 04  	sta     VCE_CTRL
  248  00:420E  28        	plp
  249  00:420F  60        	rts
  250                     
  251                     
  252                     ; ***************************************************************************
  253                     ; ***************************************************************************
  254                     ;
  255                     ;
  256                     
  257  00:4210            copy_palette:   
  258  00:4210  C2        	cly
  259  00:4211            .loop:
  260  00:4211  B1 F8     	lda     [_ax],y
  261  00:4213  C8        	iny
  262  00:4214  8D 04 04  	sta     VCE_DATA_LO
  263  00:4217  B1 F8     	lda     [_ax],y
  264  00:4219  C8        	iny
  265  00:421A  8D 05 04  	sta     VCE_DATA_HI
  266  00:421D  C0 20     	cpy     #32
  267  00:421F  D0 F0     	bne     .loop
  268  00:4221  60        	rts
  269                     
  270                     
  271                     ; ***************************************************************************
  272                     ; ***************************************************************************
  273                     
  274                     ; VDC constants for 240 & 256 wide display.
  275                     
  276           0000      VCE_CR_5MHz  = $00
  277                     
  278           0302      VDC_HSR_240  = $0302
  279           041D      VDC_HDR_240  = $041D
  280                     
  281           0202      VDC_HSR_256  = $0202
  282           041F      VDC_HDR_256  = $041F
  283                     
  284                     ; VDC constants for 320 & 336 wide display.
  285                     
  286           0001      VCE_CR_7MHz  = $01
  287                     
  288           0502      VDC_HSR_320  = $0502
  289           0427      VDC_HDR_320  = $0427
  290                     
  291           0402      VDC_HSR_336  = $0402
  292           0429      VDC_HDR_336  = $0429
  293                     
  294                     ; VDC constants for 480 & 512 wide display.
  295                     
  296           0002      VCE_CR_10MHz = $02
  297                     
  298           0C02      VDC_HSR_480  = $0C02
  299           043C      VDC_HDR_480  = $043C
  300                     
  301           0B02      VDC_HSR_512  = $0B02
  302           043F      VDC_HDR_512  = $043F
  303                     
  304                     ; VDC constants for 200, 224 & 240 high display.
  305                     
  306           2302      VDC_VPR_200  = $2302
  307           00C7      VDC_VDW_200  = $00C7
  308           0018      VDC_VCR_200  = $0018
  309                     
  310           1702      VDC_VPR_224  = $1702
  311           00DF      VDC_VDW_224  = $00DF
  312           000C      VDC_VCR_224  = $000C
  313                     
  314           0F02      VDC_VPR_240  = $0F02
  315           00EF      VDC_VDW_240  = $00EF
  316           0004      VDC_VCR_240  = $0004 ; $00F6
  317                     
  318                     ; VDC constants for different BAT screen sizes.
  319                     
  320           0000      VDC_MWR_32x32  = $0000
  321           0040      VDC_MWR_32x64  = $0040
  322                     
  323           0010      VDC_MWR_64x32  = $0010
  324           0050      VDC_MWR_64x64  = $0050
  325                     
  326           0020      VDC_MWR_128x32 = $0020
  327           0060      VDC_MWR_128x64 = $0060
  328                     
  329                     ; Table of VDC values to set on boot.
  330                     
  331  00:4222            boot_video_mode:
  332  00:4222  05        	.db     VDC_CR                  ; Control Register
  333  00:4223  00 00     	.dw     $0000
  334  00:4225  06        	.db     VDC_RCR                 ; Raster Counter Register
  335  00:4226  00 00     	.dw     $0000
  336  00:4228  07        	.db     VDC_BXR                 ; Background X-Scroll Register
  337  00:4229  00 00     	.dw     $0000
  338  00:422B  08        	.db     VDC_BYR                 ; Background Y-Scroll Register
  339  00:422C  00 00     	.dw     $0000
  340  00:422E  09        	.db     VDC_MWR                 ; Memory-access Width Register
  341  00:422F  50 00     	.dw     VDC_MWR_64x64
  342  00:4231  0A        	.db     VDC_HSR                 ; Horizontal Sync Register
  343  00:4232  02 02     	.dw     VDC_HSR_256
  344  00:4234  0B        	.db     VDC_HDR                 ; Horizontal Display Register
  345  00:4235  1F 04     	.dw     VDC_HDR_256
  346  00:4237  0C        	.db     VDC_VPR                 ; Vertical Sync Register
  347  00:4238  02 17     	.dw     VDC_VPR_224
  348  00:423A  0D        	.db     VDC_VDW                 ; Vertical Display Register
  349  00:423B  DF 00     	.dw     VDC_VDW_224
  350  00:423D  0E        	.db     VDC_VCR                 ; Vertical Display END position Register
  351  00:423E  0C 00     	.dw     VDC_VCR_224
  352  00:4240  0F        	.db     VDC_DCR                 ; DMA Control Register
  353  00:4241  10 00     	.dw     $0010
  354  00:4243  13        	.db     VDC_SATB                ; SATB  address of the SATB
  355  00:4244  00 10     	.dw     satb_vram
  356  00:4246  00        	.db     0
  357                     
  358                     ;block height arrays
#[2]   blocks.asm
  359                     	.include "blocks.asm"
    1                     ; blocks.asm: Block height arrays
    2                     ; Copyright (C) 2020 Nathan Misner
    3                     
    4                     ; This program is free software; you can redistribute it and/or
    5                     ; modify it under the terms of version 2 of the GNU General Public
    6                     ; License as published by the Free Software Foundation.
    7                     
    8                     ; This program is distributed in the hope that it will be useful,
    9                     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   10                     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   11                     ; GNU General Public License for more details.
   12                     
   13                     ; You should have received a copy of the GNU General Public License
   14                     ; along with this program; if not, see
   15                     ; <https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>
   16                     
   17           4247      	.code
   18           0000      	.bank 0
   19  00:4247            block_arrs:
   20                     ;empty block
   21  00:4247            HeightEmpty:
   22  00:4247  00 00 00  	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       00:424A  00 00 00  
       00:424D  00 00 00  
       00:4250  00 00 00  
       00:4253  00 00 00  
       00:4256  00        
   23                     	
   24                     ;full block
   25  00:4257            HeightFull:
   26  00:4257  10 10 10  	.db 16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
       00:425A  10 10 10  
       00:425D  10 10 10  
       00:4260  10 10 10  
       00:4263  10 10 10  
       00:4266  10        
   27                     	
   28                     ;45 degree
   29  00:4267            Height45:
   30  00:4267  00 01 02  	.db 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
       00:426A  03 04 05  
       00:426D  06 07 08  
       00:4270  09 0A 0B  
       00:4273  0C 0D 0E  
       00:4276  0F        
   31                     	
   32                     ;45 degree reversed
   33  00:4277            Height45R:
   34  00:4277  0F 0E 0D  	.db 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
       00:427A  0C 0B 0A  
       00:427D  09 08 07  
       00:4280  06 05 04  
       00:4283  03 02 01  
       00:4286  00        
   35                     	
   36                     ;22.5 degree part 1
   37  00:4287            Height2251:
   38  00:4287  00 00 01  	.db 0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7
       00:428A  01 02 02  
       00:428D  03 03 04  
       00:4290  04 05 05  
       00:4293  06 06 07  
       00:4296  07        
   39                     	
   40                     ;22.5 degree part 1 reversed
   41  00:4297            Height2251R:
   42  00:4297  07 07 06  	.db 7,7,6,6,5,5,4,4,3,3,2,2,1,1,0,0
       00:429A  06 05 05  
       00:429D  04 04 03  
       00:42A0  03 02 02  
       00:42A3  01 01 00  
       00:42A6  00        
   43                     	
   44                     ;22.5 degree part 2
   45  00:42A7            Height2252:
   46  00:42A7  08 08 09  	.db 8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15
       00:42AA  09 0A 0A  
       00:42AD  0B 0B 0C  
       00:42B0  0C 0D 0D  
       00:42B3  0E 0E 0F  
       00:42B6  0F        
   47                     	
   48                     ;22.5 degree part 2 reversed
   49  00:42B7            Height2252R:
   50  00:42B7  0F 0F 0E  	.db 15,15,14,14,13,13,12,12,11,11,10,10,9,9,8,8
       00:42BA  0E 0D 0D  
       00:42BD  0C 0C 0B  
       00:42C0  0B 0A 0A  
       00:42C3  09 09 08  
       00:42C6  08        
   51                     
   52                     	
#[1]   main.asm
  360                     	
