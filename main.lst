#[1]   main.asm
   18           0001      	.bank 1
   19           602F      	.code
   20                     
   21           000E      NUM_ROWS equ 14 ;14 rows (256x224 resolution, 224/16)
   22           0010      NUM_COLS equ 16 ;16 columns (256x224 resolution, 256/16)
   23           0020      MAP_WIDTH equ 32
   24           0020      MAP_HEIGHT equ 32
   25                     
   26                     ;load a level into vram
   27                     ;_si: map pointer
   28  01:602F            scroll_fill:
   29                     	stwz <_di ;pointer to vram BAT address
       01:602F  64 F0     	stz	LOW_BYTE <_di
       01:6031  64 F1     	stz	HIGH_BYTE <_di
   30  01:6033  A9 20     	lda #MAP_HEIGHT
   31  01:6035  85 FE     	sta <_dl
   32  01:6037            .col_loop:
   33                     ;tile num = (num >> 3) * $20 + (num & 7) * 2
   34                     ;         = ((num & $fff8) << 2) + ((num & 7) << 1)
   35  01:6037  A2 20     	ldx #MAP_WIDTH
   36  01:6039  C2        	cly
   37  01:603A            .row_loop:
   38  01:603A  B1 EE     	lda [<_si],y
   39  01:603C  85 F8     	sta <_al ;_ax is the first "num"
   40                     	;((num & 7) << 1)
   41  01:603E  29 07     	and #$7
   42  01:6040  0A        	asl a
   43  01:6041  85 FA     	sta <_bl ;_bx is the second "num"
   44                     
   45  01:6043  C8        	iny
   46  01:6044  B1 EE     	lda [<_si],y
   47  01:6046  85 F9     	sta <_ah
   48  01:6048  64 FB     	stz <_bh
   49  01:604A  C8        	iny
   50                     	;((num & #$fff8) << 2)
   51                     	andw <_ax,#$fff8
       01:604B  A5 F8     	lda	LOW_BYTE <_ax
       01:604D  29 F8     	and LOW_BYTE #$fff8
       01:604F  85 F8     	sta LOW_BYTE <_ax
       01:6051  A5 F9     	lda HIGH_BYTE <_ax
       01:6053  29 FF     	and HIGH_BYTE #$fff8
       01:6055  85 F9     	sta HIGH_BYTE <_ax
   52                     	aslw <_ax
       01:6057  06 F8     	asl	<_ax		; word-sized value (at stated
       01:6059  26 F9     	rol	<_ax+1		; memory location)
   53                     	aslw <_ax
       01:605B  06 F8     	asl	<_ax		; word-sized value (at stated
       01:605D  26 F9     	rol	<_ax+1		; memory location)
   54                     	addw <_ax,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:605F  18        	clc
       01:6060  A5 FA     	lda	LOW_BYTE <_bx
       01:6062  65 F8     	adc	LOW_BYTE <_ax
       01:6064  85 FA     	sta	LOW_BYTE <_bx
       01:6066  A5 FB     	lda	HIGH_BYTE <_bx
       01:6068  65 F9     	adc	HIGH_BYTE <_ax
       01:606A  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   55                     	addw #$200,<_bx ;tile numbers start at $200
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:606C  18        	clc
       01:606D  A5 FA     	lda	LOW_BYTE <_bx
       01:606F  69 00     	adc	LOW_BYTE #$200
       01:6071  85 FA     	sta	LOW_BYTE <_bx
       01:6073  A5 FB     	lda	HIGH_BYTE <_bx
       01:6075  69 02     	adc	HIGH_BYTE #$200
       01:6077  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   56                     	;correct tile number for upper left corner of 16x16 tile now in _bx
   57                     	vreg #VDC_MAWR
       01:6079  A9 00     	lda	#VDC_MAWR
       01:607B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:607D  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   58                     	stw <_di,video_data
       01:607F  A5 F0     	lda	LOW_BYTE <_di
       01:6081  8D 02 00  	sta	LOW_BYTE video_data
       01:6084  A5 F1     	lda	HIGH_BYTE <_di
       01:6086  8D 03 00  	sta	HIGH_BYTE video_data
   59                     	vreg #VDC_VWR
       01:6089  A9 02     	lda	#VDC_VWR
       01:608B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:608D  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   60                     	stw <_bx,video_data
       01:608F  A5 FA     	lda	LOW_BYTE <_bx
       01:6091  8D 02 00  	sta	LOW_BYTE video_data
       01:6094  A5 FB     	lda	HIGH_BYTE <_bx
       01:6096  8D 03 00  	sta	HIGH_BYTE video_data
   61                     	;upper right corner
   62                     	incw <_bx
       01:6099  E6 FA     	inc	<_bx		; value at stated memory
       01:609B  D0 02     	bne	.x_00011		; location
       01:609D  E6 FB     	inc	<_bx+1
       01:609F            .x_00011:
   63                     	stw <_bx,video_data
       01:609F  A5 FA     	lda	LOW_BYTE <_bx
       01:60A1  8D 02 00  	sta	LOW_BYTE video_data
       01:60A4  A5 FB     	lda	HIGH_BYTE <_bx
       01:60A6  8D 03 00  	sta	HIGH_BYTE video_data
   64                     	;lower left corner
   65                     	addw #$f,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:60A9  18        	clc
       01:60AA  A5 FA     	lda	LOW_BYTE <_bx
       01:60AC  69 0F     	adc	LOW_BYTE #$f
       01:60AE  85 FA     	sta	LOW_BYTE <_bx
       01:60B0  A5 FB     	lda	HIGH_BYTE <_bx
       01:60B2  69 00     	adc	HIGH_BYTE #$f
       01:60B4  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
   66                     	;screen is on next row (64x64 tilemap)
   67                     	addw #$40,<_di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:60B6  18        	clc
       01:60B7  A5 F0     	lda	LOW_BYTE <_di
       01:60B9  69 40     	adc	LOW_BYTE #$40
       01:60BB  85 F0     	sta	LOW_BYTE <_di
       01:60BD  A5 F1     	lda	HIGH_BYTE <_di
       01:60BF  69 00     	adc	HIGH_BYTE #$40
       01:60C1  85 F1     	sta	HIGH_BYTE <_di
                          .endif
   68                     	vreg #VDC_MAWR
       01:60C3  A9 00     	lda	#VDC_MAWR
       01:60C5  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:60C7  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   69                     	stw <_di,video_data
       01:60C9  A5 F0     	lda	LOW_BYTE <_di
       01:60CB  8D 02 00  	sta	LOW_BYTE video_data
       01:60CE  A5 F1     	lda	HIGH_BYTE <_di
       01:60D0  8D 03 00  	sta	HIGH_BYTE video_data
   70                     	vreg #VDC_VWR
       01:60D3  A9 02     	lda	#VDC_VWR
       01:60D5  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:60D7  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   71                     	stw <_bx,video_data
       01:60D9  A5 FA     	lda	LOW_BYTE <_bx
       01:60DB  8D 02 00  	sta	LOW_BYTE video_data
       01:60DE  A5 FB     	lda	HIGH_BYTE <_bx
       01:60E0  8D 03 00  	sta	HIGH_BYTE video_data
   72                     	;lower right corner
   73                     	incw <_bx
       01:60E3  E6 FA     	inc	<_bx		; value at stated memory
       01:60E5  D0 02     	bne	.x_00019		; location
       01:60E7  E6 FB     	inc	<_bx+1
       01:60E9            .x_00019:
   74                     	stw <_bx,video_data
       01:60E9  A5 FA     	lda	LOW_BYTE <_bx
       01:60EB  8D 02 00  	sta	LOW_BYTE video_data
       01:60EE  A5 FB     	lda	HIGH_BYTE <_bx
       01:60F0  8D 03 00  	sta	HIGH_BYTE video_data
   75                     	;restore vram address to where it should be for the next tile
   76                     	subw #$3e,<_di ;each row is $40, so subtracting $3e is like
       01:60F3  38        	sec
       01:60F4  A5 F0     	lda	LOW_BYTE <_di
       01:60F6  E9 3E     	sbc	LOW_BYTE #$3e
       01:60F8  85 F0     	sta	LOW_BYTE <_di
       01:60FA  A5 F1     	lda	HIGH_BYTE <_di
       01:60FC  E9 00     	sbc	HIGH_BYTE #$3e
       01:60FE  85 F1     	sta	HIGH_BYTE <_di
   77                     	vreg #VDC_MAWR ;subtracting $40 and adding $2
       01:6100  A9 00     	lda	#VDC_MAWR
       01:6102  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:6104  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
   78                     	stw <_di,video_data
       01:6106  A5 F0     	lda	LOW_BYTE <_di
       01:6108  8D 02 00  	sta	LOW_BYTE video_data
       01:610B  A5 F1     	lda	HIGH_BYTE <_di
       01:610D  8D 03 00  	sta	HIGH_BYTE video_data
   79                     	vreg #VDC_VWR
       01:6110  A9 02     	lda	#VDC_VWR
       01:6112  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:6114  03 02     	st0	#VDC_VWR
                          .else
                          .endif
   80  01:6116  CA        	dex
   81  01:6117  F0 03     	beq .done_row
   82  01:6119  4C 3A 60  	jmp .row_loop
   83  01:611C            .done_row:
   84  01:611C  A5 FE     	lda <_dl
   85  01:611E  3A        	dec a
   86  01:611F  F0 1F     	beq .done
   87  01:6121  85 FE     	sta <_dl
   88                     	addw #(MAP_WIDTH * 2),<_si ;map is 64x32, each tile index is 2 bytes
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6123  18        	clc
       01:6124  A5 EE     	lda	LOW_BYTE <_si
       01:6126  69 40     	adc	LOW_BYTE #(MAP_WIDTH * 2)
       01:6128  85 EE     	sta	LOW_BYTE <_si
       01:612A  A5 EF     	lda	HIGH_BYTE <_si
       01:612C  69 00     	adc	HIGH_BYTE #(MAP_WIDTH * 2)
       01:612E  85 EF     	sta	HIGH_BYTE <_si
                          .endif
   89                     	addw #(MAP_WIDTH * 2),<_di ;skip every other row of the tilemap, plus the remainder
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6130  18        	clc
       01:6131  A5 F0     	lda	LOW_BYTE <_di
       01:6133  69 40     	adc	LOW_BYTE #(MAP_WIDTH * 2)
       01:6135  85 F0     	sta	LOW_BYTE <_di
       01:6137  A5 F1     	lda	HIGH_BYTE <_di
       01:6139  69 00     	adc	HIGH_BYTE #(MAP_WIDTH * 2)
       01:613B  85 F1     	sta	HIGH_BYTE <_di
                          .endif
   90  01:613D  4C 37 60  	jmp .col_loop  ;left over from this tilemap
   91  01:6140            .done:
   92  01:6140  60        	rts
   93                     	
#[1]   main.asm
   46                     	
   47                     	; Player routines
#[2]   player.asm
   48                     	.include "player.asm"
    1                     ; player.asm: Player movement code
    2                     ; Copyright (C) 2020 Nathan Misner
    3                     
    4                     ; This program is free software; you can redistribute it and/or
    5                     ; modify it under the terms of version 2 of the GNU General Public
    6                     ; License as published by the Free Software Foundation.
    7                     
    8                     ; This program is distributed in the hope that it will be useful,
    9                     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   10                     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   11                     ; GNU General Public License for more details.
   12                     
   13                     ; You should have received a copy of the GNU General Public License
   14                     ; along with this program; if not, see
   15                     ; <https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>
   18           E000      	.data
   19           0001      	.bank 1
   20           6141      	.code
   21                     
   22           0400      TOP_SPEED .equ $400
   23           0080      ACCEL .equ $80
   24           00A0      GRAVITY .equ $a0
   25           0070      JUMP_GRAVITY .equ $70
   26           0098      PLAYERSPR_X .equ 152 ;onscreen sprite position
   27           00A0      PLAYERSPR_Y .equ 160
   28           0010      PLAYER_WIDTH .equ 16
   29           0020      PLAYER_HEIGHT .equ 32
   30           0008      TSENSOR_HEIGHT .equ 8
   31           0018      BSENSOR_HEIGHT .equ 24
   32           0000      STATE_GROUND .equ 0
   33           0001      STATE_AIR .equ 1
   34                     
   35           0180      FRAME_STAND .equ ($C0*2)
   36           0182      FRAME_WALK1 .equ ($C1*2)
   37           0188      FRAME_WALK2 .equ ($C4*2)
   38           018A      FRAME_JUMP .equ ($C5*2)
   39           000A      FRAME_TIMER .equ 10 ;number of screen frames before changing animation frames
   40                     
   41  01:6141            player_walk:
   42  01:6141  82 01     	dw FRAME_WALK1,FRAME_STAND,FRAME_WALK2,FRAME_STAND
       01:6143  80 01     
       01:6145  88 01     
       01:6147  80 01     
   43  01:6149            end_player_walk:
   44                     
   45  01:6149            player_init:
   46                     	;write player sprite to satb
   47                     	stw #PLAYERSPR_Y,satb ;y pos
       01:6149  A9 A0     	lda	LOW_BYTE #PLAYERSPR_Y
       01:614B  8D 7C 26  	sta	LOW_BYTE satb
       01:614E  A9 00     	lda	HIGH_BYTE #PLAYERSPR_Y
       01:6150  8D 7D 26  	sta	HIGH_BYTE satb
   48                     	stw #PLAYERSPR_X,satb+2 ;x pos
       01:6153  A9 98     	lda	LOW_BYTE #PLAYERSPR_X
       01:6155  8D 7E 26  	sta	LOW_BYTE satb+2
       01:6158  A9 00     	lda	HIGH_BYTE #PLAYERSPR_X
       01:615A  8D 7F 26  	sta	HIGH_BYTE satb+2
   49                     	stw #($3000/32),satb+4 ;tile number
       01:615D  A9 80     	lda	LOW_BYTE #($3000/32)
       01:615F  8D 80 26  	sta	LOW_BYTE satb+4
       01:6162  A9 01     	lda	HIGH_BYTE #($3000/32)
       01:6164  8D 81 26  	sta	HIGH_BYTE satb+4
   50                     	stw	#%0_0_01_0_00_0_1_000_0000,satb+6 ;Attributes
       01:6167  A9 80     	lda	LOW_BYTE #%0_0_01_0_00_0_1_000_0000
       01:6169  8D 82 26  	sta	LOW_BYTE satb+6
       01:616C  A9 10     	lda	HIGH_BYTE #%0_0_01_0_00_0_1_000_0000
       01:616E  8D 83 26  	sta	HIGH_BYTE satb+6
   51                     	stw #PLAYERSPR_X,<player_x+1
       01:6171  A9 98     	lda	LOW_BYTE #PLAYERSPR_X
       01:6173  85 12     	sta	LOW_BYTE <player_x+1
       01:6175  A9 00     	lda	HIGH_BYTE #PLAYERSPR_X
       01:6177  85 13     	sta	HIGH_BYTE <player_x+1
   52                     	stw #PLAYERSPR_Y,<player_y+1
       01:6179  A9 A0     	lda	LOW_BYTE #PLAYERSPR_Y
       01:617B  85 15     	sta	LOW_BYTE <player_y+1
       01:617D  A9 00     	lda	HIGH_BYTE #PLAYERSPR_Y
       01:617F  85 16     	sta	HIGH_BYTE <player_y+1
   53                     	
   54  01:6181  64 1B     	stz <player_state
   55                     	
   56  01:6183  60        	rts
   57                     
   58  01:6184            player_iterate:
   59                     ;-----horizontal movement-----
   60  01:6184  5F 0F 21  	bbr5 <joypad,.done_right
   61                     	cmpw #TOP_SPEED,<player_dx
       01:6187  A5 18     	lda	HIGH_BYTE <player_dx
       01:6189  C9 04     	cmp	HIGH_BYTE #TOP_SPEED
       01:618B  D0 04     	bne	.x_00033
       01:618D  A5 17     	lda	LOW_BYTE <player_dx
       01:618F  C9 00     	cmp	LOW_BYTE #TOP_SPEED
       01:6191            .x_00033:
   62  01:6191  10 15     	bpl .done_right
   63                     	addw #ACCEL,<player_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6193  18        	clc
       01:6194  A5 17     	lda	LOW_BYTE <player_dx
       01:6196  69 80     	adc	LOW_BYTE #ACCEL
       01:6198  85 17     	sta	LOW_BYTE <player_dx
       01:619A  A5 18     	lda	HIGH_BYTE <player_dx
       01:619C  69 00     	adc	HIGH_BYTE #ACCEL
       01:619E  85 18     	sta	HIGH_BYTE <player_dx
                          .endif
   64                     	;clear mirror bit when going right
   65  01:61A0  AD 83 26  	lda satb+7
   66  01:61A3  29 F7     	and #%11110111
   67  01:61A5  8D 83 26  	sta satb+7	
   68  01:61A8            .done_right:
   69  01:61A8  7F 0F 23  	bbr7 <joypad,.done_left
   70                     	cmpw #-TOP_SPEED,<player_dx
       01:61AB  A5 18     	lda	HIGH_BYTE <player_dx
       01:61AD  C9 FC     	cmp	HIGH_BYTE #-TOP_SPEED
       01:61AF  D0 04     	bne	.x_00035
       01:61B1  A5 17     	lda	LOW_BYTE <player_dx
       01:61B3  C9 00     	cmp	LOW_BYTE #-TOP_SPEED
       01:61B5            .x_00035:
   71  01:61B5  30 17     	bmi .done_left
   72  01:61B7  F0 15     	beq .done_left
   73                     	;set mirror bit when going left
   74  01:61B9  AD 83 26  	lda satb+7
   75  01:61BC  09 08     	ora #%00001000
   76  01:61BE  8D 83 26  	sta satb+7	
   77                     	subw #ACCEL,<player_dx
       01:61C1  38        	sec
       01:61C2  A5 17     	lda	LOW_BYTE <player_dx
       01:61C4  E9 80     	sbc	LOW_BYTE #ACCEL
       01:61C6  85 17     	sta	LOW_BYTE <player_dx
       01:61C8  A5 18     	lda	HIGH_BYTE <player_dx
       01:61CA  E9 00     	sbc	HIGH_BYTE #ACCEL
       01:61CC  85 18     	sta	HIGH_BYTE <player_dx
   78  01:61CE            .done_left:
   79                     	;deceleration only happens when not pressing left or right
   80  01:61CE  A5 0F     	lda <joypad
   81  01:61D0  29 A0     	and #%10100000
   82  01:61D2  D0 4C     	bne .done_decel
   83                     	cmpw #0,<player_dx
       01:61D4  A5 18     	lda	HIGH_BYTE <player_dx
       01:61D6  C9 00     	cmp	HIGH_BYTE #0
       01:61D8  D0 04     	bne	.x_00037
       01:61DA  A5 17     	lda	LOW_BYTE <player_dx
       01:61DC  C9 00     	cmp	LOW_BYTE #0
       01:61DE            .x_00037:
   84                     	;if player_dx is 0, don't decelerate
   85  01:61DE  F0 40     	beq .done_decel
   86  01:61E0  10 02     	bpl .decel_right
   87  01:61E2  30 1F     	bmi .decel_left
   88  01:61E4            .decel_right:
   89                     	subw #ACCEL,<player_dx
       01:61E4  38        	sec
       01:61E5  A5 17     	lda	LOW_BYTE <player_dx
       01:61E7  E9 80     	sbc	LOW_BYTE #ACCEL
       01:61E9  85 17     	sta	LOW_BYTE <player_dx
       01:61EB  A5 18     	lda	HIGH_BYTE <player_dx
       01:61ED  E9 00     	sbc	HIGH_BYTE #ACCEL
       01:61EF  85 18     	sta	HIGH_BYTE <player_dx
   90                     	;if value goes under zero, make it zero
   91                     	cmpw #0,<player_dx
       01:61F1  A5 18     	lda	HIGH_BYTE <player_dx
       01:61F3  C9 00     	cmp	HIGH_BYTE #0
       01:61F5  D0 04     	bne	.x_00039
       01:61F7  A5 17     	lda	LOW_BYTE <player_dx
       01:61F9  C9 00     	cmp	LOW_BYTE #0
       01:61FB            .x_00039:
   92  01:61FB  10 04     	bpl .dont_zero_right
   93                     	stwz <player_dx
       01:61FD  64 17     	stz	LOW_BYTE <player_dx
       01:61FF  64 18     	stz	HIGH_BYTE <player_dx
   94  01:6201            .dont_zero_right:
   95  01:6201  80 1D     	bra .done_decel
   96  01:6203            .decel_left:
   97                     	addw #ACCEL,<player_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6203  18        	clc
       01:6204  A5 17     	lda	LOW_BYTE <player_dx
       01:6206  69 80     	adc	LOW_BYTE #ACCEL
       01:6208  85 17     	sta	LOW_BYTE <player_dx
       01:620A  A5 18     	lda	HIGH_BYTE <player_dx
       01:620C  69 00     	adc	HIGH_BYTE #ACCEL
       01:620E  85 18     	sta	HIGH_BYTE <player_dx
                          .endif
   98                     	; if value goes over zero, make it zero
   99                     	cmpw #0,<player_dx
       01:6210  A5 18     	lda	HIGH_BYTE <player_dx
       01:6212  C9 00     	cmp	HIGH_BYTE #0
       01:6214  D0 04     	bne	.x_00042
       01:6216  A5 17     	lda	LOW_BYTE <player_dx
       01:6218  C9 00     	cmp	LOW_BYTE #0
       01:621A            .x_00042:
  100  01:621A  30 04     	bmi .done_decel
  101                     	stwz <player_dx
       01:621C  64 17     	stz	LOW_BYTE <player_dx
       01:621E  64 18     	stz	HIGH_BYTE <player_dx
  102  01:6220            .done_decel:
  103                     	;add dx to player_x
  104  01:6220  A5 18     	lda <player_dx+1
  105  01:6222  29 80     	and #%10000000
  106  01:6224  D0 15     	bne .negative_add
  107                     	;positive add
  108                     	addw <player_dx,<player_x
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6226  18        	clc
       01:6227  A5 11     	lda	LOW_BYTE <player_x
       01:6229  65 17     	adc	LOW_BYTE <player_dx
       01:622B  85 11     	sta	LOW_BYTE <player_x
       01:622D  A5 12     	lda	HIGH_BYTE <player_x
       01:622F  65 18     	adc	HIGH_BYTE <player_dx
       01:6231  85 12     	sta	HIGH_BYTE <player_x
                          .endif
  109  01:6233  A5 13     	lda <player_x+2
  110  01:6235  69 00     	adc #$0
  111  01:6237  85 13     	sta <player_x+2
  112  01:6239  80 13     	bra .done_add
  113  01:623B            .negative_add:
  114                     	addw <player_dx,<player_x
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:623B  18        	clc
       01:623C  A5 11     	lda	LOW_BYTE <player_x
       01:623E  65 17     	adc	LOW_BYTE <player_dx
       01:6240  85 11     	sta	LOW_BYTE <player_x
       01:6242  A5 12     	lda	HIGH_BYTE <player_x
       01:6244  65 18     	adc	HIGH_BYTE <player_dx
       01:6246  85 12     	sta	HIGH_BYTE <player_x
                          .endif
  115  01:6248  A5 13     	lda <player_x+2
  116  01:624A  69 FF     	adc #$ff
  117  01:624C  85 13     	sta <player_x+2
  118  01:624E            .done_add:
  119                     ;-----collision detection-----
  120                     	;top left
  121                     	stw <player_x+1,<_ax
       01:624E  A5 12     	lda	LOW_BYTE <player_x+1
       01:6250  85 F8     	sta	LOW_BYTE <_ax
       01:6252  A5 13     	lda	HIGH_BYTE <player_x+1
       01:6254  85 F9     	sta	HIGH_BYTE <_ax
  122                     	stw <player_y+1,<_bx
       01:6256  A5 15     	lda	LOW_BYTE <player_y+1
       01:6258  85 FA     	sta	LOW_BYTE <_bx
       01:625A  A5 16     	lda	HIGH_BYTE <player_y+1
       01:625C  85 FB     	sta	HIGH_BYTE <_bx
  123                     	addw #TSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:625E  18        	clc
       01:625F  A5 FA     	lda	LOW_BYTE <_bx
       01:6261  69 08     	adc	LOW_BYTE #TSENSOR_HEIGHT
       01:6263  85 FA     	sta	LOW_BYTE <_bx
       01:6265  A5 FB     	lda	HIGH_BYTE <_bx
       01:6267  69 00     	adc	HIGH_BYTE #TSENSOR_HEIGHT
       01:6269  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  124  01:626B  20 E8 65  	jsr get_height
  125  01:626E  F0 03     	beq .nohcollision_left
  126  01:6270  4C F9 62  	jmp .hcollision_left
  127  01:6273            .nohcollision_left
  128                     	;bottom left
  129                     	stw <player_x+1,<_ax
       01:6273  A5 12     	lda	LOW_BYTE <player_x+1
       01:6275  85 F8     	sta	LOW_BYTE <_ax
       01:6277  A5 13     	lda	HIGH_BYTE <player_x+1
       01:6279  85 F9     	sta	HIGH_BYTE <_ax
  130                     	stw <player_y+1,<_bx
       01:627B  A5 15     	lda	LOW_BYTE <player_y+1
       01:627D  85 FA     	sta	LOW_BYTE <_bx
       01:627F  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6281  85 FB     	sta	HIGH_BYTE <_bx
  131                     	addw #BSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6283  18        	clc
       01:6284  A5 FA     	lda	LOW_BYTE <_bx
       01:6286  69 18     	adc	LOW_BYTE #BSENSOR_HEIGHT
       01:6288  85 FA     	sta	LOW_BYTE <_bx
       01:628A  A5 FB     	lda	HIGH_BYTE <_bx
       01:628C  69 00     	adc	HIGH_BYTE #BSENSOR_HEIGHT
       01:628E  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  132  01:6290  20 E8 65  	jsr get_height
  133  01:6293  C9 10     	cmp #$10
  134  01:6295  F0 62     	beq .hcollision_left
  135                     	;top right
  136                     	stw <player_x+1,<_ax
       01:6297  A5 12     	lda	LOW_BYTE <player_x+1
       01:6299  85 F8     	sta	LOW_BYTE <_ax
       01:629B  A5 13     	lda	HIGH_BYTE <player_x+1
       01:629D  85 F9     	sta	HIGH_BYTE <_ax
  137                     	addw #PLAYER_WIDTH,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:629F  18        	clc
       01:62A0  A5 F8     	lda	LOW_BYTE <_ax
       01:62A2  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:62A4  85 F8     	sta	LOW_BYTE <_ax
       01:62A6  A5 F9     	lda	HIGH_BYTE <_ax
       01:62A8  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:62AA  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  138                     	stw <player_y+1,<_bx
       01:62AC  A5 15     	lda	LOW_BYTE <player_y+1
       01:62AE  85 FA     	sta	LOW_BYTE <_bx
       01:62B0  A5 16     	lda	HIGH_BYTE <player_y+1
       01:62B2  85 FB     	sta	HIGH_BYTE <_bx
  139                     	addw #TSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62B4  18        	clc
       01:62B5  A5 FA     	lda	LOW_BYTE <_bx
       01:62B7  69 08     	adc	LOW_BYTE #TSENSOR_HEIGHT
       01:62B9  85 FA     	sta	LOW_BYTE <_bx
       01:62BB  A5 FB     	lda	HIGH_BYTE <_bx
       01:62BD  69 00     	adc	HIGH_BYTE #TSENSOR_HEIGHT
       01:62BF  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  140  01:62C1  20 E8 65  	jsr get_height
  141  01:62C4  D0 54     	bne .hcollision_right
  142                     	;bottom right
  143                     	stw <player_x+1,<_ax
       01:62C6  A5 12     	lda	LOW_BYTE <player_x+1
       01:62C8  85 F8     	sta	LOW_BYTE <_ax
       01:62CA  A5 13     	lda	HIGH_BYTE <player_x+1
       01:62CC  85 F9     	sta	HIGH_BYTE <_ax
  144                     	addw #PLAYER_WIDTH,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62CE  18        	clc
       01:62CF  A5 F8     	lda	LOW_BYTE <_ax
       01:62D1  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:62D3  85 F8     	sta	LOW_BYTE <_ax
       01:62D5  A5 F9     	lda	HIGH_BYTE <_ax
       01:62D7  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:62D9  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  145                     	stw <player_y+1,<_bx
       01:62DB  A5 15     	lda	LOW_BYTE <player_y+1
       01:62DD  85 FA     	sta	LOW_BYTE <_bx
       01:62DF  A5 16     	lda	HIGH_BYTE <player_y+1
       01:62E1  85 FB     	sta	HIGH_BYTE <_bx
  146                     	addw #BSENSOR_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:62E3  18        	clc
       01:62E4  A5 FA     	lda	LOW_BYTE <_bx
       01:62E6  69 18     	adc	LOW_BYTE #BSENSOR_HEIGHT
       01:62E8  85 FA     	sta	LOW_BYTE <_bx
       01:62EA  A5 FB     	lda	HIGH_BYTE <_bx
       01:62EC  69 00     	adc	HIGH_BYTE #BSENSOR_HEIGHT
       01:62EE  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  147  01:62F0  20 E8 65  	jsr get_height
  148  01:62F3  C9 10     	cmp #$10
  149  01:62F5  F0 23     	beq .hcollision_right
  150                     	
  151  01:62F7  80 40     	bra .done_hcollision
  152  01:62F9            .hcollision_left:
  153                     	stwz <player_dx
       01:62F9  64 17     	stz	LOW_BYTE <player_dx
       01:62FB  64 18     	stz	HIGH_BYTE <player_dx
  154                     	andw <player_x+1,#$fff0
       01:62FD  A5 12     	lda	LOW_BYTE <player_x+1
       01:62FF  29 F0     	and LOW_BYTE #$fff0
       01:6301  85 12     	sta LOW_BYTE <player_x+1
       01:6303  A5 13     	lda HIGH_BYTE <player_x+1
       01:6305  29 FF     	and HIGH_BYTE #$fff0
       01:6307  85 13     	sta HIGH_BYTE <player_x+1
  155                     	addw #$10,<player_x+1
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6309  18        	clc
       01:630A  A5 12     	lda	LOW_BYTE <player_x+1
       01:630C  69 10     	adc	LOW_BYTE #$10
       01:630E  85 12     	sta	LOW_BYTE <player_x+1
       01:6310  A5 13     	lda	HIGH_BYTE <player_x+1
       01:6312  69 00     	adc	HIGH_BYTE #$10
       01:6314  85 13     	sta	HIGH_BYTE <player_x+1
                          .endif
  156  01:6316  64 11     	stz <player_x
  157  01:6318  80 1F     	bra .done_hcollision
  158  01:631A            .hcollision_right:
  159                     	stwz <player_dx
       01:631A  64 17     	stz	LOW_BYTE <player_dx
       01:631C  64 18     	stz	HIGH_BYTE <player_dx
  160                     	andw <player_x+1,#$fff0
       01:631E  A5 12     	lda	LOW_BYTE <player_x+1
       01:6320  29 F0     	and LOW_BYTE #$fff0
       01:6322  85 12     	sta LOW_BYTE <player_x+1
       01:6324  A5 13     	lda HIGH_BYTE <player_x+1
       01:6326  29 FF     	and HIGH_BYTE #$fff0
       01:6328  85 13     	sta HIGH_BYTE <player_x+1
  161                     	decw <player_x+1
       01:632A  38        	sec			; value at stated memory
       01:632B  A5 12     	lda	<player_x+1		; location
       01:632D  E9 01     	sbc	#1
       01:632F  85 12     	sta	<player_x+1
       01:6331  A5 13     	lda	<player_x+1+1
       01:6333  E9 00     	sbc	#0
       01:6335  85 13     	sta	<player_x+1+1
  162  01:6337  64 11     	stz <player_x
  163  01:6339            .done_hcollision:	
  164                     ;-----jumping & falling-----
  165  01:6339  0F 10 12  	bbr0 <joyedge,.done_one ;handle jump button press
  166  01:633C  A5 1B     	lda <player_state
  167  01:633E  C9 01     	cmp #STATE_AIR
  168  01:6340  F0 0C     	beq .done_one
  169                     	stw #-($900),<player_dy
       01:6342  A9 00     	lda	LOW_BYTE #-($900)
       01:6344  85 19     	sta	LOW_BYTE <player_dy
       01:6346  A9 F7     	lda	HIGH_BYTE #-($900)
       01:6348  85 1A     	sta	HIGH_BYTE <player_dy
  170  01:634A  A9 01     	lda #STATE_AIR
  171  01:634C  85 1B     	sta <player_state
  172  01:634E            .done_one:	
  173                     	
  174  01:634E  A5 1B     	lda <player_state
  175  01:6350  C9 01     	cmp #STATE_AIR
  176  01:6352  D0 5D     	bne .done_air
  177                     	;jump higher if player's still holding I
  178  01:6354  0F 0F 1B  	bbr0 <joypad,.normal_gravity
  179                     	cmpw #$0,<player_dy
       01:6357  A5 1A     	lda	HIGH_BYTE <player_dy
       01:6359  C9 00     	cmp	HIGH_BYTE #$0
       01:635B  D0 04     	bne	.x_00067
       01:635D  A5 19     	lda	LOW_BYTE <player_dy
       01:635F  C9 00     	cmp	LOW_BYTE #$0
       01:6361            .x_00067:
  180  01:6361  10 0F     	bpl .normal_gravity
  181                     	addw #JUMP_GRAVITY,<player_dy
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6363  18        	clc
       01:6364  A5 19     	lda	LOW_BYTE <player_dy
       01:6366  69 70     	adc	LOW_BYTE #JUMP_GRAVITY
       01:6368  85 19     	sta	LOW_BYTE <player_dy
       01:636A  A5 1A     	lda	HIGH_BYTE <player_dy
       01:636C  69 00     	adc	HIGH_BYTE #JUMP_GRAVITY
       01:636E  85 1A     	sta	HIGH_BYTE <player_dy
                          .endif
  182  01:6370  80 0D     	bra .done_gravity
  183                     	
  184  01:6372            .normal_gravity:
  185                     	addw #GRAVITY,<player_dy
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6372  18        	clc
       01:6373  A5 19     	lda	LOW_BYTE <player_dy
       01:6375  69 A0     	adc	LOW_BYTE #GRAVITY
       01:6377  85 19     	sta	LOW_BYTE <player_dy
       01:6379  A5 1A     	lda	HIGH_BYTE <player_dy
       01:637B  69 00     	adc	HIGH_BYTE #GRAVITY
       01:637D  85 1A     	sta	HIGH_BYTE <player_dy
                          .endif
  186  01:637F            .done_gravity:
  187                     	;add dy to player_y
  188  01:637F  A5 1A     	lda <player_dy+1
  189  01:6381  29 80     	and #%10000000
  190  01:6383  D0 17     	bne .negative_dy
  191                     	;positive add
  192                     	addw <player_dy,<player_y
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6385  18        	clc
       01:6386  A5 14     	lda	LOW_BYTE <player_y
       01:6388  65 19     	adc	LOW_BYTE <player_dy
       01:638A  85 14     	sta	LOW_BYTE <player_y
       01:638C  A5 15     	lda	HIGH_BYTE <player_y
       01:638E  65 1A     	adc	HIGH_BYTE <player_dy
       01:6390  85 15     	sta	HIGH_BYTE <player_y
                          .endif
  193  01:6392  AD 16 20  	lda player_y+2
  194  01:6395  69 00     	adc #$0
  195  01:6397  8D 16 20  	sta player_y+2
  196  01:639A  80 15     	bra .done_air
  197  01:639C            .negative_dy:
  198                     	addw <player_dy,<player_y
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:639C  18        	clc
       01:639D  A5 14     	lda	LOW_BYTE <player_y
       01:639F  65 19     	adc	LOW_BYTE <player_dy
       01:63A1  85 14     	sta	LOW_BYTE <player_y
       01:63A3  A5 15     	lda	HIGH_BYTE <player_y
       01:63A5  65 1A     	adc	HIGH_BYTE <player_dy
       01:63A7  85 15     	sta	HIGH_BYTE <player_y
                          .endif
  199  01:63A9  AD 16 20  	lda player_y+2
  200  01:63AC  69 FF     	adc #$ff
  201  01:63AE  8D 16 20  	sta player_y+2
  202  01:63B1            .done_air:
  203                     	
  204                     ;-----collision detection-----
  205                     	cmpw #$0,<player_dy ;don't check for ground collision if moving upwards
       01:63B1  A5 1A     	lda	HIGH_BYTE <player_dy
       01:63B3  C9 00     	cmp	HIGH_BYTE #$0
       01:63B5  D0 04     	bne	.x_00072
       01:63B7  A5 19     	lda	LOW_BYTE <player_dy
       01:63B9  C9 00     	cmp	LOW_BYTE #$0
       01:63BB            .x_00072:
  206  01:63BB  10 05     	bpl .floor_collision
  207  01:63BD  F0 03     	beq .floor_collision
  208  01:63BF  4C 98 64  	jmp .ceil_collision
  209                     	
  210  01:63C2            .floor_collision:
  211                     ;check left foot
  212                     	stw <player_x+1,<_ax
       01:63C2  A5 12     	lda	LOW_BYTE <player_x+1
       01:63C4  85 F8     	sta	LOW_BYTE <_ax
       01:63C6  A5 13     	lda	HIGH_BYTE <player_x+1
       01:63C8  85 F9     	sta	HIGH_BYTE <_ax
  213                     	stw <player_y+1,<_bx
       01:63CA  A5 15     	lda	LOW_BYTE <player_y+1
       01:63CC  85 FA     	sta	LOW_BYTE <_bx
       01:63CE  A5 16     	lda	HIGH_BYTE <player_y+1
       01:63D0  85 FB     	sta	HIGH_BYTE <_bx
  214                     	addw #PLAYER_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:63D2  18        	clc
       01:63D3  A5 FA     	lda	LOW_BYTE <_bx
       01:63D5  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:63D7  85 FA     	sta	LOW_BYTE <_bx
       01:63D9  A5 FB     	lda	HIGH_BYTE <_bx
       01:63DB  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:63DD  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  215  01:63DF  20 68 65  	jsr get_sensor
  216                     	stw <_dx,<pad
       01:63E2  A5 FE     	lda	LOW_BYTE <_dx
       01:63E4  85 00     	sta	LOW_BYTE <pad
       01:63E6  A5 FF     	lda	HIGH_BYTE <_dx
       01:63E8  85 01     	sta	HIGH_BYTE <pad
  217                     ;check right foot
  218                     	stw <player_x+1,<_ax
       01:63EA  A5 12     	lda	LOW_BYTE <player_x+1
       01:63EC  85 F8     	sta	LOW_BYTE <_ax
       01:63EE  A5 13     	lda	HIGH_BYTE <player_x+1
       01:63F0  85 F9     	sta	HIGH_BYTE <_ax
  219                     	addw #PLAYER_WIDTH,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:63F2  18        	clc
       01:63F3  A5 F8     	lda	LOW_BYTE <_ax
       01:63F5  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:63F7  85 F8     	sta	LOW_BYTE <_ax
       01:63F9  A5 F9     	lda	HIGH_BYTE <_ax
       01:63FB  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:63FD  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  220                     	stw <player_y+1,<_bx
       01:63FF  A5 15     	lda	LOW_BYTE <player_y+1
       01:6401  85 FA     	sta	LOW_BYTE <_bx
       01:6403  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6405  85 FB     	sta	HIGH_BYTE <_bx
  221                     	addw #PLAYER_HEIGHT,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6407  18        	clc
       01:6408  A5 FA     	lda	LOW_BYTE <_bx
       01:640A  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:640C  85 FA     	sta	LOW_BYTE <_bx
       01:640E  A5 FB     	lda	HIGH_BYTE <_bx
       01:6410  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:6412  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  222  01:6414  20 68 65  	jsr get_sensor
  223                     	cmpw <pad,<_dx
       01:6417  A5 FF     	lda	HIGH_BYTE <_dx
       01:6419  C5 01     	cmp	HIGH_BYTE <pad
       01:641B  D0 04     	bne	.x_00081
       01:641D  A5 FE     	lda	LOW_BYTE <_dx
       01:641F  C5 00     	cmp	LOW_BYTE <pad
       01:6421            .x_00081:
  224  01:6421  30 08     	bmi .left_higher
  225                     	stw <_dx,<pad
       01:6423  A5 FE     	lda	LOW_BYTE <_dx
       01:6425  85 00     	sta	LOW_BYTE <pad
       01:6427  A5 FF     	lda	HIGH_BYTE <_dx
       01:6429  85 01     	sta	HIGH_BYTE <pad
  226  01:642B            .left_higher:
  227                     	cmpw #$fff0,<pad ;-16 is the value returned if no ground is found
       01:642B  A5 01     	lda	HIGH_BYTE <pad
       01:642D  C9 FF     	cmp	HIGH_BYTE #$fff0
       01:642F  D0 04     	bne	.x_00083
       01:6431  A5 00     	lda	LOW_BYTE <pad
       01:6433  C9 F0     	cmp	LOW_BYTE #$fff0
       01:6435            .x_00083:
  228  01:6435  D0 07     	bne .on_ground 
  229  01:6437  A9 01     	lda #STATE_AIR
  230  01:6439  85 1B     	sta <player_state
  231  01:643B  4C EE 64  	jmp .done_ground
  232  01:643E            .on_ground:
  233  01:643E  A9 00     	lda #STATE_GROUND
  234  01:6440  85 1B     	sta <player_state
  235                     	stwz <player_dy
       01:6442  64 19     	stz	LOW_BYTE <player_dy
       01:6444  64 1A     	stz	HIGH_BYTE <player_dy
  236                     	;foot pos in ax
  237                     	stw <player_y+1,<_ax
       01:6446  A5 15     	lda	LOW_BYTE <player_y+1
       01:6448  85 F8     	sta	LOW_BYTE <_ax
       01:644A  A5 16     	lda	HIGH_BYTE <player_y+1
       01:644C  85 F9     	sta	HIGH_BYTE <_ax
  238                     	addw #PLAYER_HEIGHT,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:644E  18        	clc
       01:644F  A5 F8     	lda	LOW_BYTE <_ax
       01:6451  69 20     	adc	LOW_BYTE #PLAYER_HEIGHT
       01:6453  85 F8     	sta	LOW_BYTE <_ax
       01:6455  A5 F9     	lda	HIGH_BYTE <_ax
       01:6457  69 00     	adc	HIGH_BYTE #PLAYER_HEIGHT
       01:6459  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  239                     	;place feet at bottom of block
  240                     	andw <_ax,#$fff0
       01:645B  A5 F8     	lda	LOW_BYTE <_ax
       01:645D  29 F0     	and LOW_BYTE #$fff0
       01:645F  85 F8     	sta LOW_BYTE <_ax
       01:6461  A5 F9     	lda HIGH_BYTE <_ax
       01:6463  29 FF     	and HIGH_BYTE #$fff0
       01:6465  85 F9     	sta HIGH_BYTE <_ax
  241                     	addw #16,<_ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6467  18        	clc
       01:6468  A5 F8     	lda	LOW_BYTE <_ax
       01:646A  69 10     	adc	LOW_BYTE #16
       01:646C  85 F8     	sta	LOW_BYTE <_ax
       01:646E  A5 F9     	lda	HIGH_BYTE <_ax
       01:6470  69 00     	adc	HIGH_BYTE #16
       01:6472  85 F9     	sta	HIGH_BYTE <_ax
                          .endif
  242                     	;move up by highest sensor's height
  243                     	subw <pad,<_ax
       01:6474  38        	sec
       01:6475  A5 F8     	lda	LOW_BYTE <_ax
       01:6477  E5 00     	sbc	LOW_BYTE <pad
       01:6479  85 F8     	sta	LOW_BYTE <_ax
       01:647B  A5 F9     	lda	HIGH_BYTE <_ax
       01:647D  E5 01     	sbc	HIGH_BYTE <pad
       01:647F  85 F9     	sta	HIGH_BYTE <_ax
  244                     	;translate from foot pos to sprite pos
  245                     	subw #PLAYER_HEIGHT,<_ax
       01:6481  38        	sec
       01:6482  A5 F8     	lda	LOW_BYTE <_ax
       01:6484  E9 20     	sbc	LOW_BYTE #PLAYER_HEIGHT
       01:6486  85 F8     	sta	LOW_BYTE <_ax
       01:6488  A5 F9     	lda	HIGH_BYTE <_ax
       01:648A  E9 00     	sbc	HIGH_BYTE #PLAYER_HEIGHT
       01:648C  85 F9     	sta	HIGH_BYTE <_ax
  246                     	stw <_ax,<player_y+1
       01:648E  A5 F8     	lda	LOW_BYTE <_ax
       01:6490  85 15     	sta	LOW_BYTE <player_y+1
       01:6492  A5 F9     	lda	HIGH_BYTE <_ax
       01:6494  85 16     	sta	HIGH_BYTE <player_y+1
  247  01:6496  80 56     	bra .done_ground
  248  01:6498            .ceil_collision:
  249                     	;top left
  250                     	stw <player_x+1,<_ax
       01:6498  A5 12     	lda	LOW_BYTE <player_x+1
       01:649A  85 F8     	sta	LOW_BYTE <_ax
       01:649C  A5 13     	lda	HIGH_BYTE <player_x+1
       01:649E  85 F9     	sta	HIGH_BYTE <_ax
  251                     	stw <player_y+1,<_bx
       01:64A0  A5 15     	lda	LOW_BYTE <player_y+1
       01:64A2  85 FA     	sta	LOW_BYTE <_bx
       01:64A4  A5 16     	lda	HIGH_BYTE <player_y+1
       01:64A6  85 FB     	sta	HIGH_BYTE <_bx
  252  01:64A8  20 E8 65  	jsr get_height
  253  01:64AB  D0 22     	bne .ceil_rebound
  254                     	;top right
  255                     	stw <player_x+1,<_ax
       01:64AD  A5 12     	lda	LOW_BYTE <player_x+1
       01:64AF  85 F8     	sta	LOW_BYTE <_ax
       01:64B1  A5 13     	lda	HIGH_BYTE <player_x+1
       01:64B3  85 F9     	sta	HIGH_BYTE <_ax
  256                     	addw #PLAYER_WIDTH,<_ax	
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:64B5  18        	clc
       01:64B6  A5 F8     	lda	LOW_BYTE <_ax	
       01:64B8  69 10     	adc	LOW_BYTE #PLAYER_WIDTH
       01:64BA  85 F8     	sta	LOW_BYTE <_ax	
       01:64BC  A5 F9     	lda	HIGH_BYTE <_ax	
       01:64BE  69 00     	adc	HIGH_BYTE #PLAYER_WIDTH
       01:64C0  85 F9     	sta	HIGH_BYTE <_ax	
                          .endif
  257                     	stw <player_y+1,<_bx
       01:64C2  A5 15     	lda	LOW_BYTE <player_y+1
       01:64C4  85 FA     	sta	LOW_BYTE <_bx
       01:64C6  A5 16     	lda	HIGH_BYTE <player_y+1
       01:64C8  85 FB     	sta	HIGH_BYTE <_bx
  258  01:64CA  20 E8 65  	jsr get_height
  259  01:64CD  F0 1F     	beq .done_ground
  260  01:64CF            .ceil_rebound:
  261                     	stwz <player_dy
       01:64CF  64 19     	stz	LOW_BYTE <player_dy
       01:64D1  64 1A     	stz	HIGH_BYTE <player_dy
  262                     	andw <player_y+1,#$fff0
       01:64D3  A5 15     	lda	LOW_BYTE <player_y+1
       01:64D5  29 F0     	and LOW_BYTE #$fff0
       01:64D7  85 15     	sta LOW_BYTE <player_y+1
       01:64D9  A5 16     	lda HIGH_BYTE <player_y+1
       01:64DB  29 FF     	and HIGH_BYTE #$fff0
       01:64DD  85 16     	sta HIGH_BYTE <player_y+1
  263                     	addw #$10,<player_y+1
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:64DF  18        	clc
       01:64E0  A5 15     	lda	LOW_BYTE <player_y+1
       01:64E2  69 10     	adc	LOW_BYTE #$10
       01:64E4  85 15     	sta	LOW_BYTE <player_y+1
       01:64E6  A5 16     	lda	HIGH_BYTE <player_y+1
       01:64E8  69 00     	adc	HIGH_BYTE #$10
       01:64EA  85 16     	sta	HIGH_BYTE <player_y+1
                          .endif
  264  01:64EC  64 14     	stz <player_y
  265  01:64EE            .done_ground:
  266                     	
  267                     ;-----done collision detection-----
  268                     	stw <player_x+1,<scroll_x
       01:64EE  A5 12     	lda	LOW_BYTE <player_x+1
       01:64F0  85 08     	sta	LOW_BYTE <scroll_x
       01:64F2  A5 13     	lda	HIGH_BYTE <player_x+1
       01:64F4  85 09     	sta	HIGH_BYTE <scroll_x
  269                     	subw #PLAYERSPR_X,<scroll_x	
       01:64F6  38        	sec
       01:64F7  A5 08     	lda	LOW_BYTE <scroll_x	
       01:64F9  E9 98     	sbc	LOW_BYTE #PLAYERSPR_X
       01:64FB  85 08     	sta	LOW_BYTE <scroll_x	
       01:64FD  A5 09     	lda	HIGH_BYTE <scroll_x	
       01:64FF  E9 00     	sbc	HIGH_BYTE #PLAYERSPR_X
       01:6501  85 09     	sta	HIGH_BYTE <scroll_x	
  270                     	stw <player_y+1,<scroll_y
       01:6503  A5 15     	lda	LOW_BYTE <player_y+1
       01:6505  85 0A     	sta	LOW_BYTE <scroll_y
       01:6507  A5 16     	lda	HIGH_BYTE <player_y+1
       01:6509  85 0B     	sta	HIGH_BYTE <scroll_y
  271                     	subw #PLAYERSPR_Y,<scroll_y
       01:650B  38        	sec
       01:650C  A5 0A     	lda	LOW_BYTE <scroll_y
       01:650E  E9 A0     	sbc	LOW_BYTE #PLAYERSPR_Y
       01:6510  85 0A     	sta	LOW_BYTE <scroll_y
       01:6512  A5 0B     	lda	HIGH_BYTE <scroll_y
       01:6514  E9 00     	sbc	HIGH_BYTE #PLAYERSPR_Y
       01:6516  85 0B     	sta	HIGH_BYTE <scroll_y
  272                     	
  273                     ;-----animation-----
  274  01:6518  A5 1B     	lda <player_state
  275  01:651A  C9 01     	cmp #STATE_AIR
  276  01:651C  D0 0E     	bne .no_jump
  277                     	stw #FRAME_JUMP,satb+4
       01:651E  A9 8A     	lda	LOW_BYTE #FRAME_JUMP
       01:6520  8D 80 26  	sta	LOW_BYTE satb+4
       01:6523  A9 01     	lda	HIGH_BYTE #FRAME_JUMP
       01:6525  8D 81 26  	sta	HIGH_BYTE satb+4
  278  01:6528  64 1C     	stz <player_frame
  279  01:652A  80 3B     	bra .done_anim
  280  01:652C            .no_jump:
  281  01:652C  A5 17     	lda <player_dx
  282  01:652E  05 18     	ora <player_dx+1
  283  01:6530  F0 29     	beq .still
  284  01:6532  A5 1D     	lda <player_timer
  285  01:6534  C9 0A     	cmp #FRAME_TIMER
  286  01:6536  F0 04     	beq .animate_player
  287  01:6538  E6 1D     	inc <player_timer
  288  01:653A  80 2B     	bra .done_anim
  289  01:653C            .animate_player
  290  01:653C  64 1D     	stz <player_timer
  291  01:653E  A6 1C     	ldx <player_frame
  292  01:6540  BD 41 61  	lda player_walk,x
  293  01:6543  8D 80 26  	sta satb+4
  294  01:6546  E8        	inx
  295  01:6547  BD 41 61  	lda player_walk,x
  296  01:654A  8D 81 26  	sta satb+5
  297  01:654D  E8        	inx
  298  01:654E  8A        	txa
  299  01:654F  C9 08     	cmp #(end_player_walk - player_walk)
  300  01:6551  D0 04     	bne .no_reset_frame
  301  01:6553  64 1C     	stz <player_frame
  302  01:6555  80 10     	bra .done_anim
  303  01:6557            .no_reset_frame:
  304  01:6557  86 1C     	stx <player_frame
  305  01:6559  80 0C     	bra .done_anim
  306  01:655B            .still:
  307                     	stw #FRAME_STAND,satb+4
       01:655B  A9 80     	lda	LOW_BYTE #FRAME_STAND
       01:655D  8D 80 26  	sta	LOW_BYTE satb+4
       01:6560  A9 01     	lda	HIGH_BYTE #FRAME_STAND
       01:6562  8D 81 26  	sta	HIGH_BYTE satb+4
  308  01:6565  64 1C     	stz <player_frame
  309  01:6567            .done_anim:
  310  01:6567  60        	rts
  311                     	
  312                     ;returns number of pixels to move up/down in dx
  313                     ;ax: foot x pos
  314                     ;bx: foot y pos
  315  01:6568            get_sensor:
  316                     	stw <_ax,<_si
       01:6568  A5 F8     	lda	LOW_BYTE <_ax
       01:656A  85 EE     	sta	LOW_BYTE <_si
       01:656C  A5 F9     	lda	HIGH_BYTE <_ax
       01:656E  85 EF     	sta	HIGH_BYTE <_si
  317                     	stw <_bx,<_di
       01:6570  A5 FA     	lda	LOW_BYTE <_bx
       01:6572  85 F0     	sta	LOW_BYTE <_di
       01:6574  A5 FB     	lda	HIGH_BYTE <_bx
       01:6576  85 F1     	sta	HIGH_BYTE <_di
  318  01:6578  20 E8 65  	jsr get_height
  319  01:657B  85 FE     	sta <_dl
  320  01:657D  64 FF     	stz <_dh
  321                     	;if height is 0, check below block
  322  01:657F  F0 06     	beq .check_below
  323  01:6581  C9 10     	cmp #16
  324                     	;if height is 16, check above block
  325  01:6583  F0 33     	beq .check_above
  326                     	;otherwise end
  327  01:6585  80 60     	bra .end
  328  01:6587            .check_below:
  329                     	;add 16 to height (below tile)
  330                     	stw <_si,<_ax
       01:6587  A5 EE     	lda	LOW_BYTE <_si
       01:6589  85 F8     	sta	LOW_BYTE <_ax
       01:658B  A5 EF     	lda	HIGH_BYTE <_si
       01:658D  85 F9     	sta	HIGH_BYTE <_ax
  331                     	stw <_di,<_bx
       01:658F  A5 F0     	lda	LOW_BYTE <_di
       01:6591  85 FA     	sta	LOW_BYTE <_bx
       01:6593  A5 F1     	lda	HIGH_BYTE <_di
       01:6595  85 FB     	sta	HIGH_BYTE <_bx
  332                     	addw #16,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6597  18        	clc
       01:6598  A5 FA     	lda	LOW_BYTE <_bx
       01:659A  69 10     	adc	LOW_BYTE #16
       01:659C  85 FA     	sta	LOW_BYTE <_bx
       01:659E  A5 FB     	lda	HIGH_BYTE <_bx
       01:65A0  69 00     	adc	HIGH_BYTE #16
       01:65A2  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  333  01:65A4  20 E8 65  	jsr get_height
  334  01:65A7  85 FE     	sta <_dl
  335                     	;we have to remove 16px from the height
  336                     	subw #16,<_dx
       01:65A9  38        	sec
       01:65AA  A5 FE     	lda	LOW_BYTE <_dx
       01:65AC  E9 10     	sbc	LOW_BYTE #16
       01:65AE  85 FE     	sta	LOW_BYTE <_dx
       01:65B0  A5 FF     	lda	HIGH_BYTE <_dx
       01:65B2  E9 00     	sbc	HIGH_BYTE #16
       01:65B4  85 FF     	sta	HIGH_BYTE <_dx
  337  01:65B6  80 2F     	bra .end
  338  01:65B8            .check_above:
  339                     	;subtract 16 from height (above tile)
  340                     	stw <_si,<_ax
       01:65B8  A5 EE     	lda	LOW_BYTE <_si
       01:65BA  85 F8     	sta	LOW_BYTE <_ax
       01:65BC  A5 EF     	lda	HIGH_BYTE <_si
       01:65BE  85 F9     	sta	HIGH_BYTE <_ax
  341                     	stw <_di,<_bx
       01:65C0  A5 F0     	lda	LOW_BYTE <_di
       01:65C2  85 FA     	sta	LOW_BYTE <_bx
       01:65C4  A5 F1     	lda	HIGH_BYTE <_di
       01:65C6  85 FB     	sta	HIGH_BYTE <_bx
  342                     	subw #16,<_bx
       01:65C8  38        	sec
       01:65C9  A5 FA     	lda	LOW_BYTE <_bx
       01:65CB  E9 10     	sbc	LOW_BYTE #16
       01:65CD  85 FA     	sta	LOW_BYTE <_bx
       01:65CF  A5 FB     	lda	HIGH_BYTE <_bx
       01:65D1  E9 00     	sbc	HIGH_BYTE #16
       01:65D3  85 FB     	sta	HIGH_BYTE <_bx
  343  01:65D5  20 E8 65  	jsr get_height
  344  01:65D8  85 FE     	sta <_dl
  345                     	;we have to add 16px to the height
  346                     	addw #16,<_dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:65DA  18        	clc
       01:65DB  A5 FE     	lda	LOW_BYTE <_dx
       01:65DD  69 10     	adc	LOW_BYTE #16
       01:65DF  85 FE     	sta	LOW_BYTE <_dx
       01:65E1  A5 FF     	lda	HIGH_BYTE <_dx
       01:65E3  69 00     	adc	HIGH_BYTE #16
       01:65E5  85 FF     	sta	HIGH_BYTE <_dx
                          .endif
  347  01:65E7            .end:
  348  01:65E7  60        	rts
  349                     
  350                     
  351                     ;returns height of current tile in al
  352                     ;ax: x pos (pixels)
  353                     ;bx: y pos (pixels)	
  354  01:65E8            get_height:
  355                     ;tile offset = ((y >> 4) << 6) + (x >> 4) << 1
  356                     ;            = ((y & #$fff0) << 2) + (x >> 3) & #$fffe
  357                     	;pc engine adds 32 to sprite x positions and 64 to sprite y positions
  358                     	;so origin is 32 pixels left of screen and 64 above
  359                     	subw #32,<_ax
       01:65E8  38        	sec
       01:65E9  A5 F8     	lda	LOW_BYTE <_ax
       01:65EB  E9 20     	sbc	LOW_BYTE #32
       01:65ED  85 F8     	sta	LOW_BYTE <_ax
       01:65EF  A5 F9     	lda	HIGH_BYTE <_ax
       01:65F1  E9 00     	sbc	HIGH_BYTE #32
       01:65F3  85 F9     	sta	HIGH_BYTE <_ax
  360                     	subw #64,<_bx
       01:65F5  38        	sec
       01:65F6  A5 FA     	lda	LOW_BYTE <_bx
       01:65F8  E9 40     	sbc	LOW_BYTE #64
       01:65FA  85 FA     	sta	LOW_BYTE <_bx
       01:65FC  A5 FB     	lda	HIGH_BYTE <_bx
       01:65FE  E9 00     	sbc	HIGH_BYTE #64
       01:6600  85 FB     	sta	HIGH_BYTE <_bx
  361                     	andw <_bx,#$fff0
       01:6602  A5 FA     	lda	LOW_BYTE <_bx
       01:6604  29 F0     	and LOW_BYTE #$fff0
       01:6606  85 FA     	sta LOW_BYTE <_bx
       01:6608  A5 FB     	lda HIGH_BYTE <_bx
       01:660A  29 FF     	and HIGH_BYTE #$fff0
       01:660C  85 FB     	sta HIGH_BYTE <_bx
  362                     	aslw <_bx
       01:660E  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6610  26 FB     	rol	<_bx+1		; memory location)
  363                     	aslw <_bx
       01:6612  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6614  26 FB     	rol	<_bx+1		; memory location)
  364                     	stw <_ax,<_cx
       01:6616  A5 F8     	lda	LOW_BYTE <_ax
       01:6618  85 FC     	sta	LOW_BYTE <_cx
       01:661A  A5 F9     	lda	HIGH_BYTE <_ax
       01:661C  85 FD     	sta	HIGH_BYTE <_cx
  365                     	lsrw <_cx
       01:661E  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:6620  66 FC     	ror	<_cx		; location)
  366                     	lsrw <_cx
       01:6622  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:6624  66 FC     	ror	<_cx		; location)
  367                     	lsrw <_cx
       01:6626  46 FD     	lsr	<_cx+1		; value (at stated memory
       01:6628  66 FC     	ror	<_cx		; location)
  368                     	andw <_cx,#$fffe
       01:662A  A5 FC     	lda	LOW_BYTE <_cx
       01:662C  29 FE     	and LOW_BYTE #$fffe
       01:662E  85 FC     	sta LOW_BYTE <_cx
       01:6630  A5 FD     	lda HIGH_BYTE <_cx
       01:6632  29 FF     	and HIGH_BYTE #$fffe
       01:6634  85 FD     	sta HIGH_BYTE <_cx
  369                     	addw <_cx,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6636  18        	clc
       01:6637  A5 FA     	lda	LOW_BYTE <_bx
       01:6639  65 FC     	adc	LOW_BYTE <_cx
       01:663B  85 FA     	sta	LOW_BYTE <_bx
       01:663D  A5 FB     	lda	HIGH_BYTE <_bx
       01:663F  65 FD     	adc	HIGH_BYTE <_cx
       01:6641  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  370                     	addw #map_load,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:6643  18        	clc
       01:6644  A5 FA     	lda	LOW_BYTE <_bx
       01:6646  69 60     	adc	LOW_BYTE #map_load
       01:6648  85 FA     	sta	LOW_BYTE <_bx
       01:664A  A5 FB     	lda	HIGH_BYTE <_bx
       01:664C  69 A0     	adc	HIGH_BYTE #map_load
       01:664E  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  371                     	;<_bx is the pointer to the tile
  372  01:6650  B2 FA     	lda [<_bx]
  373  01:6652  AA        	tax
  374                     	;get height array index for the tile
  375  01:6653  BD 20 A0  	lda heights_load,x
  376  01:6656  85 FA     	sta <_bl
  377  01:6658  64 FB     	stz <_bh
  378                     	;each height array is 16 bytes, so shift left by 4 to get the offset
  379                     	aslw <_bx
       01:665A  06 FA     	asl	<_bx		; word-sized value (at stated
       01:665C  26 FB     	rol	<_bx+1		; memory location)
  380                     	aslw <_bx
       01:665E  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6660  26 FB     	rol	<_bx+1		; memory location)
  381                     	aslw <_bx
       01:6662  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6664  26 FB     	rol	<_bx+1		; memory location)
  382                     	aslw <_bx
       01:6666  06 FA     	asl	<_bx		; word-sized value (at stated
       01:6668  26 FB     	rol	<_bx+1		; memory location)
  383                     	addw #block_arrs,<_bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:666A  18        	clc
       01:666B  A5 FA     	lda	LOW_BYTE <_bx
       01:666D  69 47     	adc	LOW_BYTE #block_arrs
       01:666F  85 FA     	sta	LOW_BYTE <_bx
       01:6671  A5 FB     	lda	HIGH_BYTE <_bx
       01:6673  69 42     	adc	HIGH_BYTE #block_arrs
       01:6675  85 FB     	sta	HIGH_BYTE <_bx
                          .endif
  384                     	;get offset within the tile
  385  01:6677  A5 F8     	lda <_al
  386  01:6679  29 0F     	and #$f
  387  01:667B  A8        	tay
  388  01:667C  B1 FA     	lda [<_bx],y
  389  01:667E  85 F8     	sta <_al
  390  01:6680  60        	rts
  391                     	
  392                     	
#[1]   main.asm
   49                     
   50                     	;asset location on cd-rom
#[2]   cd_labels.asm
   51                     	.include "cd_labels.asm"
    1                     ;  CD-Rom Data/Overlay reference labels
    2                     ;  Generated by pyDiscMaker Version 1.12
    3                     ; (C) 2019 The DiscMaker Project
    4                     
    5           0000      _ADDR_ipl = 0
    6           1000      _SIZE_ipl = 4096
    7           0002      _SECSIZE_ipl = 2
    8                     
    9           0002      _ADDR_Main_Program = 2
   10           4000      _SIZE_Main_Program = 16384
   11           0008      _SECSIZE_Main_Program = 8
   12                     
   13           000A      _ADDR_spritegfx = 10
   14           2000      _SIZE_spritegfx = 8192
   15           0004      _SECSIZE_spritegfx = 4
   16                     
   17           000E      _ADDR_level1 = 14
   18           4000      _SIZE_level1 = 16384
   19           0008      _SECSIZE_level1 = 8
   20                     
   21           0016      _ADDR__CDROM_Specs_Padding = 22
   22           0000      _SIZE__CDROM_Specs_Padding = 262144
   23           0080      _SECSIZE__CDROM_Specs_Padding = 128
   24                     
#[1]   main.asm
   52                     
   53                     	;-----asset load pointers-----
   54           8000      tile_load equ $8000
   55           A000      pal_load equ $a000 ;palette is 32 bytes
   56           A020      heights_load equ $a020 ;height array indices
   57           A060      map_load equ $a060
   58                     
   59                     	;-----misc constants-----
   60           1000      satb_vram equ $1000 ;where satb is in vram
   61                     
   64           0000      	.data
   65                     
   66           6681      	.code
   67           0000      	.bank   0
   68           4070      	.org    $4070
   69                     
   70                     ;
   71                     ;
   72                     ;
   73  00:4070            boot:
   74  00:4070  20 99 E0  	jsr     ex_dspoff
   75  00:4073  20 81 E0  	jsr     ex_rcroff
   76  00:4076  20 87 E0  	jsr     ex_irqoff
   77  00:4079  20 30 E0  	jsr     ad_reset
   78                     
   79  00:407C  20 F2 41  	jsr     init_vce
   80                     
   81                     	stw     #boot_video_mode,_ax
       00:407F  A9 22     	lda	LOW_BYTE #boot_video_mode
       00:4081  8D F8 20  	sta	LOW_BYTE _ax
       00:4084  A9 42     	lda	HIGH_BYTE #boot_video_mode
       00:4086  8D F9 20  	sta	HIGH_BYTE _ax
   82  00:4089  20 D7 41  	jsr     init_vdc
   83                     	
   84                     	;set up vsync handler
   85                     	stw #my_vsync,sync_jmp
       00:408C  A9 80     	lda	LOW_BYTE #my_vsync
       00:408E  8D 08 22  	sta	LOW_BYTE sync_jmp
       00:4091  A9 41     	lda	HIGH_BYTE #my_vsync
       00:4093  8D 09 22  	sta	HIGH_BYTE sync_jmp
   86  00:4096  A9 30     	lda #%00110000
   87  00:4098  8D F5 20  	sta irq_m
   88  00:409B  20 96 E0  	jsr ex_dspon
   89  00:409E  20 7E E0  	jsr ex_rcron
   90  00:40A1  20 84 E0  	jsr ex_irqon
   91  00:40A4  20 7B E0  	jsr ex_vsync
   92  00:40A7  20 7B E0  	jsr ex_vsync
   93                     	
   94                     	;initialize zero-page variables
   95  00:40AA  9C 00 20  	stz start_vars
   96  00:40AD  73 00 20  	tii start_vars,start_vars+1,(end_vars-start_vars)
       00:40B0  01 20 1E  
       00:40B3  00        
   97                     	
   98                     	;load sprites
   99                     	cd_load _ADDR_spritegfx,#$68,#_SECSIZE_spritegfx
       00:40B4  64 FC     	stz <_cl ;sector number (bits 24-16)
       00:40B6  A9 00     	lda #HIGH(_ADDR_spritegfx) ;sector number (bits 15-8)
       00:40B8  85 FD     	sta <_ch
       00:40BA  A9 0A     	lda #LOW(_ADDR_spritegfx) ;sector number (bits 7-0)
       00:40BC  85 FE     	sta <_dl
       00:40BE  A9 02     	lda #2 ;write to a bank
       00:40C0  85 FF     	sta <_dh
       00:40C2  A9 68     	lda #$68 ;write starting at bank n
       00:40C4  85 FA     	sta <_bl
       00:40C6  A9 04     	lda #_SECSIZE_spritegfx ;write n sectors
       00:40C8  85 F8     	sta <_al
       00:40CA  20 00 60  	jsr cd_saferead
  100                     	;load level gfx & map
  101                     	cd_load _ADDR_level1,#$82,#_SECSIZE_level1
       00:40CD  64 FC     	stz <_cl ;sector number (bits 24-16)
       00:40CF  A9 00     	lda #HIGH(_ADDR_level1) ;sector number (bits 15-8)
       00:40D1  85 FD     	sta <_ch
       00:40D3  A9 0E     	lda #LOW(_ADDR_level1) ;sector number (bits 7-0)
       00:40D5  85 FE     	sta <_dl
       00:40D7  A9 02     	lda #2 ;write to a bank
       00:40D9  85 FF     	sta <_dh
       00:40DB  A9 82     	lda #$82 ;write starting at bank n
       00:40DD  85 FA     	sta <_bl
       00:40DF  A9 08     	lda #_SECSIZE_level1 ;write n sectors
       00:40E1  85 F8     	sta <_al
       00:40E3  20 00 60  	jsr cd_saferead
  102                     	
  103                     	;play cdda
  104                     	; lda #2 ;track 2
  105                     	; jsr cd_track
  106                     	
  107                     	;copy bg palette
  108                     	stw     #pal_load,<_ax
       00:40E6  A9 00     	lda	LOW_BYTE #pal_load
       00:40E8  85 F8     	sta	LOW_BYTE <_ax
       00:40EA  A9 A0     	lda	HIGH_BYTE #pal_load
       00:40EC  85 F9     	sta	HIGH_BYTE <_ax
  109                     	stw     #$0000,VCE_ADDR_LO
       00:40EE  A9 00     	lda	LOW_BYTE #$0000
       00:40F0  8D 02 04  	sta	LOW_BYTE VCE_ADDR_LO
       00:40F3  A9 00     	lda	HIGH_BYTE #$0000
       00:40F5  8D 03 04  	sta	HIGH_BYTE VCE_ADDR_LO
  110  00:40F8  20 10 42  	jsr     copy_palette
  111                     	
  112                     	;copy bg tiles
  113                     	vreg #VDC_MAWR
       00:40FB  A9 00     	lda	#VDC_MAWR
       00:40FD  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:40FF  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  114                     	stw #$2000,video_data
       00:4101  A9 00     	lda	LOW_BYTE #$2000
       00:4103  8D 02 00  	sta	LOW_BYTE video_data
       00:4106  A9 20     	lda	HIGH_BYTE #$2000
       00:4108  8D 03 00  	sta	HIGH_BYTE video_data
  115                     	vreg #VDC_VWR
       00:410B  A9 02     	lda	#VDC_VWR
       00:410D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:410F  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  116  00:4111  E3 00 80  	tia tile_load,video_data,$2000
       00:4114  02 00 00  
       00:4117  20        
  117                     	; ;copy bg data
  118                     	stw #map_load,<_si
       00:4118  A9 60     	lda	LOW_BYTE #map_load
       00:411A  85 EE     	sta	LOW_BYTE <_si
       00:411C  A9 A0     	lda	HIGH_BYTE #map_load
       00:411E  85 EF     	sta	HIGH_BYTE <_si
  119  00:4120  20 2F 60  	jsr scroll_fill
  120                     	
  121                     	;copy sprite palette
  122  00:4123  A9 68     	lda #$68
  123  00:4125  53 10     	tam #4
  124                     	stw #$8000,<_ax
       00:4127  A9 00     	lda	LOW_BYTE #$8000
       00:4129  85 F8     	sta	LOW_BYTE <_ax
       00:412B  A9 80     	lda	HIGH_BYTE #$8000
       00:412D  85 F9     	sta	HIGH_BYTE <_ax
  125                     	stw #$0100,VCE_ADDR_LO ;sprite palette 0
       00:412F  A9 00     	lda	LOW_BYTE #$0100
       00:4131  8D 02 04  	sta	LOW_BYTE VCE_ADDR_LO
       00:4134  A9 01     	lda	HIGH_BYTE #$0100
       00:4136  8D 03 04  	sta	HIGH_BYTE VCE_ADDR_LO
  126  00:4139  20 10 42  	jsr copy_palette
  127                     	
  128                     	;copy sprite tiles
  129                     	vreg #VDC_MAWR
       00:413C  A9 00     	lda	#VDC_MAWR
       00:413E  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:4140  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  130                     	stw #$3000,video_data
       00:4142  A9 00     	lda	LOW_BYTE #$3000
       00:4144  8D 02 00  	sta	LOW_BYTE video_data
       00:4147  A9 30     	lda	HIGH_BYTE #$3000
       00:4149  8D 03 00  	sta	HIGH_BYTE video_data
  131                     	vreg #VDC_VWR
       00:414C  A9 02     	lda	#VDC_VWR
       00:414E  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:4150  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  132  00:4152  E3 20 80  	tia $8020,video_data,$400
       00:4155  02 00 00  
       00:4158  04        
  133  00:4159  A9 82     	lda #$82
  134  00:415B  53 10     	tam #4
  135                     	
  136                     	;zero out SATB
  137  00:415D  9C 7C 26  	stz satb
  138  00:4160  73 7C 26  	tii satb,satb+1,511
       00:4163  7D 26 FF  
       00:4166  01        
  139                     	
  140  00:4167  20 49 61  	jsr player_init
  141                     	
  142                     	;init scroll
  143                     	stwz <scroll_x
       00:416A  64 08     	stz	LOW_BYTE <scroll_x
       00:416C  64 09     	stz	HIGH_BYTE <scroll_x
  144                     	stwz <scroll_y
       00:416E  64 0A     	stz	LOW_BYTE <scroll_y
       00:4170  64 0B     	stz	HIGH_BYTE <scroll_y
  145                     	
  146                     	;main loop
  147  00:4172            main:
  148                     	; ;d-pad up
  149                     	; bbr4 <joypad,.no_up
  150                     	; decw <scroll_y
  151                     ; .no_up:
  152                     	; ;d-pad right
  153                     	; bbr5 <joypad,.no_right
  154                     	; incw <scroll_x
  155                     ; .no_right:
  156                     	; ;d-pad down
  157                     	; bbr6 <joypad,.no_down
  158                     	; incw <scroll_y
  159                     ; .no_down:
  160                     	; ;d-pad left
  161                     	; bbr7 <joypad,.no_left
  162                     	; decw <scroll_x
  163                     ; .no_left:
  164                     
  165  00:4172  20 84 61  	jsr player_iterate
  166                     	
  167  00:4175  A9 01     	lda #1
  168  00:4177  85 0C     	sta <status
  169  00:4179            end_loop:
  170                     ;loop until vsync function sets status to 0
  171  00:4179  A5 0C     	lda <status
  172  00:417B  D0 FC     	bne end_loop
  173  00:417D  4C 72 41  	jmp main
  174                     	
  175  00:4180            my_vsync:	
  176                     	incw <frame
       00:4180  E6 0D     	inc	<frame		; value at stated memory
       00:4182  D0 02     	bne	.x_00150		; location
       00:4184  E6 0E     	inc	<frame+1
       00:4186            .x_00150:
  177  00:4186  64 0C     	stz <status
  178                     
  179                     	;set scroll pos
  180                     	vreg #VDC_BXR
       00:4188  A9 07     	lda	#VDC_BXR
       00:418A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:418C  03 07     	st0	#VDC_BXR
                          .else
                          .endif
  181  00:418E  A5 08     	lda <scroll_x
  182                     	stw <scroll_x,video_data
       00:4190  A5 08     	lda	LOW_BYTE <scroll_x
       00:4192  8D 02 00  	sta	LOW_BYTE video_data
       00:4195  A5 09     	lda	HIGH_BYTE <scroll_x
       00:4197  8D 03 00  	sta	HIGH_BYTE video_data
  183                     	vreg #VDC_BYR
       00:419A  A9 08     	lda	#VDC_BYR
       00:419C  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:419E  03 08     	st0	#VDC_BYR
                          .else
                          .endif
  184                     	stw <scroll_y,video_data
       00:41A0  A5 0A     	lda	LOW_BYTE <scroll_y
       00:41A2  8D 02 00  	sta	LOW_BYTE video_data
       00:41A5  A5 0B     	lda	HIGH_BYTE <scroll_y
       00:41A7  8D 03 00  	sta	HIGH_BYTE video_data
  185                     	
  186                     	;copy SATB mirror
  187                     	vreg #VDC_MAWR
       00:41AA  A9 00     	lda	#VDC_MAWR
       00:41AC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41AE  03 00     	st0	#VDC_MAWR
                          .else
                          .endif
  188                     	stw #satb_vram,video_data
       00:41B0  A9 00     	lda	LOW_BYTE #satb_vram
       00:41B2  8D 02 00  	sta	LOW_BYTE video_data
       00:41B5  A9 10     	lda	HIGH_BYTE #satb_vram
       00:41B7  8D 03 00  	sta	HIGH_BYTE video_data
  189                     	vreg #VDC_VWR
       00:41BA  A9 02     	lda	#VDC_VWR
       00:41BC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:41BE  03 02     	st0	#VDC_VWR
                          .else
                          .endif
  190  00:41C0  E3 7C 26  	tia satb,video_data,512
       00:41C3  02 00 00  
       00:41C6  02        
  191                     	
  192  00:41C7  A9 01     	lda #1 ;read joypad 1
  193  00:41C9  20 63 E0  	jsr ex_joysns
  194  00:41CC  AD 28 22  	lda joy
  195  00:41CF  85 0F     	sta <joypad
  196  00:41D1  AD 2D 22  	lda joytrg
  197  00:41D4  85 10     	sta <joyedge
  198  00:41D6  60        	rts
  199                     	
  200                     ; ***************************************************************************
  201                     ; ***************************************************************************
  202                     ;
  203                     ;
  204                     
  205                     
  206  00:41D7            init_vdc:
  207  00:41D7  08        	php
  208  00:41D8  78        	sei
  209  00:41D9  C2        	cly
  210  00:41DA            .loop:
  211  00:41DA  B1 F8     	lda     [_ax],y
  212  00:41DC  F0 12     	beq     .done
  213  00:41DE  8D 00 00  	sta     VDC_CTRL
  214  00:41E1  C8        	iny
  215  00:41E2  B1 F8     	lda     [_ax],y
  216  00:41E4  8D 02 00  	sta     VDC_DATA_LO
  217  00:41E7  C8        	iny
  218  00:41E8  B1 F8     	lda     [_ax],y
  219  00:41EA  8D 03 00  	sta     VDC_DATA_HI
  220  00:41ED  C8        	iny
  221  00:41EE  80 EA     	bra     .loop
  222  00:41F0            .done:
  223  00:41F0  28        	plp
  224  00:41F1  60        	rts
  225                     
  226                     
  227                     ; ***************************************************************************
  228                     ; ***************************************************************************
  229                     ;
  230                     ;
  231                     
  232  00:41F2            init_vce:
  233  00:41F2  08        	php
  234  00:41F3  78        	sei
  235  00:41F4  9C 02 04  	stz     VCE_ADDR_LO
  236  00:41F7  9C 03 04  	stz     VCE_ADDR_HI
  237  00:41FA  A0 02     	ldy     #$02
  238  00:41FC  82        	clx
  239  00:41FD            .loop:
  240  00:41FD  9C 04 04  	stz     VCE_DATA_LO
  241  00:4200  9C 05 04  	stz     VCE_DATA_HI
  242  00:4203  CA        	dex
  243  00:4204  D0 F7     	bne     .loop
  244  00:4206  88        	dey
  245  00:4207  D0 F4     	bne     .loop
  246  00:4209  A9 00     	lda     #VCE_CR_5MHz
  247  00:420B  8D 00 04  	sta     VCE_CTRL
  248  00:420E  28        	plp
  249  00:420F  60        	rts
  250                     
  251                     
  252                     ; ***************************************************************************
  253                     ; ***************************************************************************
  254                     ;
  255                     ;
  256                     
  257  00:4210            copy_palette:   
  258  00:4210  C2        	cly
  259  00:4211            .loop:
  260  00:4211  B1 F8     	lda     [_ax],y
  261  00:4213  C8        	iny
  262  00:4214  8D 04 04  	sta     VCE_DATA_LO
  263  00:4217  B1 F8     	lda     [_ax],y
  264  00:4219  C8        	iny
  265  00:421A  8D 05 04  	sta     VCE_DATA_HI
  266  00:421D  C0 20     	cpy     #32
  267  00:421F  D0 F0     	bne     .loop
  268  00:4221  60        	rts
  269                     
  270                     
  271                     ; ***************************************************************************
  272                     ; ***************************************************************************
  273                     
  274                     ; VDC constants for 240 & 256 wide display.
  275                     
  276           0000      VCE_CR_5MHz  = $00
  277                     
  278           0302      VDC_HSR_240  = $0302
  279           041D      VDC_HDR_240  = $041D
  280                     
  281           0202      VDC_HSR_256  = $0202
  282           041F      VDC_HDR_256  = $041F
  283                     
  284                     ; VDC constants for 320 & 336 wide display.
  285                     
  286           0001      VCE_CR_7MHz  = $01
  287                     
  288           0502      VDC_HSR_320  = $0502
  289           0427      VDC_HDR_320  = $0427
  290                     
  291           0402      VDC_HSR_336  = $0402
  292           0429      VDC_HDR_336  = $0429
  293                     
  294                     ; VDC constants for 480 & 512 wide display.
  295                     
  296           0002      VCE_CR_10MHz = $02
  297                     
  298           0C02      VDC_HSR_480  = $0C02
  299           043C      VDC_HDR_480  = $043C
  300                     
  301           0B02      VDC_HSR_512  = $0B02
  302           043F      VDC_HDR_512  = $043F
  303                     
  304                     ; VDC constants for 200, 224 & 240 high display.
  305                     
  306           2302      VDC_VPR_200  = $2302
  307           00C7      VDC_VDW_200  = $00C7
  308           0018      VDC_VCR_200  = $0018
  309                     
  310           1702      VDC_VPR_224  = $1702
  311           00DF      VDC_VDW_224  = $00DF
  312           000C      VDC_VCR_224  = $000C
  313                     
  314           0F02      VDC_VPR_240  = $0F02
  315           00EF      VDC_VDW_240  = $00EF
  316           0004      VDC_VCR_240  = $0004 ; $00F6
  317                     
  318                     ; VDC constants for different BAT screen sizes.
  319                     
  320           0000      VDC_MWR_32x32  = $0000
  321           0040      VDC_MWR_32x64  = $0040
  322                     
  323           0010      VDC_MWR_64x32  = $0010
  324           0050      VDC_MWR_64x64  = $0050
  325                     
  326           0020      VDC_MWR_128x32 = $0020
  327           0060      VDC_MWR_128x64 = $0060
  328                     
  329                     ; Table of VDC values to set on boot.
  330                     
  331  00:4222            boot_video_mode:
  332  00:4222  05        	.db     VDC_CR                  ; Control Register
  333  00:4223  00 00     	.dw     $0000
  334  00:4225  06        	.db     VDC_RCR                 ; Raster Counter Register
  335  00:4226  00 00     	.dw     $0000
  336  00:4228  07        	.db     VDC_BXR                 ; Background X-Scroll Register
  337  00:4229  00 00     	.dw     $0000
  338  00:422B  08        	.db     VDC_BYR                 ; Background Y-Scroll Register
  339  00:422C  00 00     	.dw     $0000
  340  00:422E  09        	.db     VDC_MWR                 ; Memory-access Width Register
  341  00:422F  50 00     	.dw     VDC_MWR_64x64
  342  00:4231  0A        	.db     VDC_HSR                 ; Horizontal Sync Register
  343  00:4232  02 02     	.dw     VDC_HSR_256
  344  00:4234  0B        	.db     VDC_HDR                 ; Horizontal Display Register
  345  00:4235  1F 04     	.dw     VDC_HDR_256
  346  00:4237  0C        	.db     VDC_VPR                 ; Vertical Sync Register
  347  00:4238  02 17     	.dw     VDC_VPR_224
  348  00:423A  0D        	.db     VDC_VDW                 ; Vertical Display Register
  349  00:423B  DF 00     	.dw     VDC_VDW_224
  350  00:423D  0E        	.db     VDC_VCR                 ; Vertical Display END position Register
  351  00:423E  0C 00     	.dw     VDC_VCR_224
  352  00:4240  0F        	.db     VDC_DCR                 ; DMA Control Register
  353  00:4241  10 00     	.dw     $0010
  354  00:4243  13        	.db     VDC_SATB                ; SATB  address of the SATB
  355  00:4244  00 10     	.dw     satb_vram
  356  00:4246  00        	.db     0
  357                     
  358                     ;block height arrays
#[2]   blocks.asm
  359                     	.include "blocks.asm"
    1                     ; blocks.asm: Block height arrays
    2                     ; Copyright (C) 2020 Nathan Misner
    3                     
    4                     ; This program is free software; you can redistribute it and/or
    5                     ; modify it under the terms of version 2 of the GNU General Public
    6                     ; License as published by the Free Software Foundation.
    7                     
    8                     ; This program is distributed in the hope that it will be useful,
    9                     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   10                     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   11                     ; GNU General Public License for more details.
   12                     
   13                     ; You should have received a copy of the GNU General Public License
   14                     ; along with this program; if not, see
   15                     ; <https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>
   16                     
   17           4247      	.code
   18           0000      	.bank 0
   19  00:4247            block_arrs:
   20                     ;empty block
   21  00:4247            HeightEmpty:
   22  00:4247  00 00 00  	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       00:424A  00 00 00  
       00:424D  00 00 00  
       00:4250  00 00 00  
       00:4253  00 00 00  
       00:4256  00        
   23                     	
   24                     ;full block
   25  00:4257            HeightFull:
   26  00:4257  10 10 10  	.db 16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
       00:425A  10 10 10  
       00:425D  10 10 10  
       00:4260  10 10 10  
       00:4263  10 10 10  
       00:4266  10        
   27                     	
   28                     ;45 degree
   29  00:4267            Height45:
   30  00:4267  00 01 02  	.db 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
       00:426A  03 04 05  
       00:426D  06 07 08  
       00:4270  09 0A 0B  
       00:4273  0C 0D 0E  
       00:4276  0F        
   31                     	
   32                     ;45 degree reversed
   33  00:4277            Height45R:
   34  00:4277  0F 0E 0D  	.db 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
       00:427A  0C 0B 0A  
       00:427D  09 08 07  
       00:4280  06 05 04  
       00:4283  03 02 01  
       00:4286  00        
   35                     	
   36                     ;22.5 degree part 1
   37  00:4287            Height2251:
   38  00:4287  00 00 01  	.db 0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7
       00:428A  01 02 02  
       00:428D  03 03 04  
       00:4290  04 05 05  
       00:4293  06 06 07  
       00:4296  07        
   39                     	
   40                     ;22.5 degree part 1 reversed
   41  00:4297            Height2251R:
   42  00:4297  07 07 06  	.db 7,7,6,6,5,5,4,4,3,3,2,2,1,1,0,0
       00:429A  06 05 05  
       00:429D  04 04 03  
       00:42A0  03 02 02  
       00:42A3  01 01 00  
       00:42A6  00        
   43                     	
   44                     ;22.5 degree part 2
   45  00:42A7            Height2252:
   46  00:42A7  08 08 09  	.db 8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15
       00:42AA  09 0A 0A  
       00:42AD  0B 0B 0C  
       00:42B0  0C 0D 0D  
       00:42B3  0E 0E 0F  
       00:42B6  0F        
   47                     	
   48                     ;22.5 degree part 2 reversed
   49  00:42B7            Height2252R:
   50  00:42B7  0F 0F 0E  	.db 15,15,14,14,13,13,12,12,11,11,10,10,9,9,8,8
       00:42BA  0E 0D 0D  
       00:42BD  0C 0C 0B  
       00:42C0  0B 0A 0A  
       00:42C3  09 09 08  
       00:42C6  08        
   51                     
   52                     	
#[1]   main.asm
  360                     	
